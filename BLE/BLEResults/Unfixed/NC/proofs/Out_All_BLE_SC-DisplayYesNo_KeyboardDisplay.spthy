theory BLE_SC_JW_NC_PE_OOB begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman
functions: f4/4, f5/5, f6/7, fst/1, g2/4, pair/2, resize/2, sdec/2,
           senc/2, snd/1
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2



rule (modulo E) send_authenticated[color=#9aff9a]:
   [ Out_A( <channelname, SendType, ReceiveType>, A, B, m ) ]
  -->
   [ Auth( <channelname, SendType, ReceiveType>, A, B, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) receive_authenticated[color=#9aff9a]:
   [ Auth( <channelname, SendType, ReceiveType>, A, B, m ) ]
  -->
   [ In_A( <channelname, SendType, ReceiveType>, A, B, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) send_OOB[color=#9aff9a]:
   [ Out_OOB( <channelname, SendType, ReceiveType>, m ) ]
  -->
   [ OOB( <channelname, SendType, ReceiveType>, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) receive_OOB[color=#9aff9a]:
   [ OOB( <channelname, SendType, ReceiveType>, m ) ]
  -->
   [ In_OOB( <channelname, SendType, ReceiveType>, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_InitDevice[color=#ffefd5]:
   [ Fr( ~MacAdd ), Fr( ~skI ) ]
  --[
  Unique( $D ), OnlyoneInit( ), InitD_IOCapability( 'DisplayYesNo' ),
  AFMITMI( '1' ), InitDOOBOut( '0' ), InitDOOBIn( '0' )
  ]->
   [
   !Device( $D, ~MacAdd, 'DisplayYesNo', <'0', '0'>, '1', ~skI, 'Initiator'
   )
   ]

  /* has exactly the trivial AC variant */

restriction OnlyoneInit:
  "∀ #i #j. ((OnlyoneInit( ) @ #i) ∧ (OnlyoneInit( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) Init_ResDevice[color=#ffefd5]:
   [ Fr( ~MacAdd ), Fr( ~skR ) ]
  --[
  Unique( $D ), OnlyoneRes( ), ResD_IOCapability( 'KeyboardDisplay' ),
  AFMITMR( '1' ), ResDOOBOut( '0' ), ResDOOBIn( '0' )
  ]->
   [
   !Device( $D, ~MacAdd, 'KeyboardDisplay', <'0', '0'>, '1', ~skR,
            'Responder'
   )
   ]

  /* has exactly the trivial AC variant */

restriction OnlyoneRes:
  "∀ #i #j. ((OnlyoneRes( ) @ #i) ∧ (OnlyoneRes( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) InitDOutOOBinfo[color=#bbffff]:
   [
   !Device( InitD, MacAddI, IOCapabilityI, <'1', i>, MITMI, ~skI,
            'Initiator'
   ),
   Fr( ~ri )
   ]
  -->
   [
   Out_OOB( <'OOB', 'InitD', 'ResD'>,
            <MacAddI, ~ri, f4('g'^~skI, 'g'^~skI, ~ri, '0')>
   ),
   !State_InitD_SentOOBInfo( ~ri, f4('g'^~skI, 'g'^~skI, ~ri, '0') )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDOutOOBinfo[color=#fff68f]:
   [
   !Device( ResD, MacAddR, IOCapabilityR, <'1', i>, MITMR, ~skR, 'Responder'
   ),
   Fr( ~rr )
   ]
  -->
   [
   Out_OOB( <'OOB', 'ResD', 'InitD'>,
            <MacAddR, ~rr, f4('g'^~skR, 'g'^~skR, ~rr, '0')>
   ),
   !State_ResD_SentOOBInfo( ~rr, f4('g'^~skR, 'g'^~skR, ~rr, '0') )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitDInOOBinfo[color=#bbffff]:
   [
   !Device( InitD, MacAddI, IOCapabilityI, <i, '1'>, MITMI, ~skI,
            'Initiator'
   ),
   In_OOB( <'OOB', 'ResD', 'InitD'>, <MacAddR, rb, Cb> )
   ]
  --[ OnlyoneInitInOOB( InitD ) ]->
   [ !State_InitD_RevOOBInfo( MacAddR, rb, Cb ) ]

  /* has exactly the trivial AC variant */

restriction OnlyoneInitInOOB:
  "∀ x #i #j.
    ((OnlyoneInitInOOB( x ) @ #i) ∧ (OnlyoneInitInOOB( x ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

rule (modulo E) ResDInOOBinfo[color=#fff68f]:
   [
   !Device( ResD, MacAddR, IOCapabilityR, <i, '1'>, MITMR, ~skR, 'Responder'
   ),
   In_OOB( <'OOB', 'InitD', 'ResD'>, <MacAddI, ra, Ca> )
   ]
  --[ OnlyoneResInOOB( ResD ) ]->
   [ !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ]

  /* has exactly the trivial AC variant */

restriction OnlyoneResInOOB:
  "∀ x #i #j.
    ((OnlyoneResInOOB( x ) @ #i) ∧ (OnlyoneResInOOB( x ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) Init_User[color=#ffefd5]:
   [ ] --[ OnlyoneUser( ) ]-> [ !User( $User ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Advertising[color=#fff68f]:
   [
   !Device( ResD, MacAddR, IOCapabilityR, OOBCapabilityR, MITMR, ~skR,
            'Responder'
   )
   ]
  -->
   [ Out( <ResD, MacAddR> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Scan[color=#bbffff]:
   [
   In( <ResD, MacAddR> ),
   !Device( InitD, MacAddI, IOCapabilityI, OOBCapabilityI, MITMI, ~skI,
            'Initiator'
   )
   ]
  --[ OneInitOneResD( InitD, ResD ), Neq( InitD, ResD ) ]->
   [
   State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI, ResD, MacAddR )
   ]

  /* has exactly the trivial AC variant */

restriction OneInitOneResD:
  "∀ x y z #i #j.
    ((OneInitOneResD( x, y ) @ #i) ∧ (OneInitOneResD( x, z ) @ #j)) ⇒
    ((#i = #j) ∧ (y = z))"
  // safety formula

rule (modulo E) InitDRequest[color=#bbffff]:
   [
   State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI, ResD, MacAddR )
   ]
  --[ InitD_OOBFlag( '0' ) ]->
   [
   !Pairing( InitD, ResD ),
   Out( <MacAddI, MacAddR, InitD, 'Req', IOCapabilityI, '0', MITMI, '16'> ),
   InitDReqPairing( InitD, MacAddI, IOCapabilityI, '0', MITMI, ResD,
                    MacAddR, ~skI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDSResponse[color=#fff68f]:
   [
   In( <MacAddI, MacAddR, InitD, 'Req', IOCapabilityI, OOBflagI, MITMI, 
        KeySizeInit>
   ),
   !Device( ResD, MacAddR, IOCapabilityR, OOBCapabilityR, MITMR, ~skR,
            'Responder'
   )
   ]
  --[ AFResDOnlyOneThread( ), ResD_OOBFlag( '0' ) ]->
   [
   !Pairing( InitD, ResD ),
   ResDStartPairing( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                     IOCapabilityR, '0', MITMR, ~skR
   ),
   Out( <MacAddR, MacAddI, 'response', IOCapabilityR, '0', MITMR, '16'> ),
   !InitDKeySize( KeySizeInit )
   ]

  /* has exactly the trivial AC variant */

restriction ResDOnlyOneThread:
  "∀ #i #j.
    ((AFResDOnlyOneThread( ) @ #i) ∧ (AFResDOnlyOneThread( ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

rule (modulo E) InitDRequestWithOOBflagI1[color=#bbffff]:
   [
   State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI, ResD, MacAddR
   ),
   !State_InitD_RevOOBInfo( MacAddR, rb, Cb )
   ]
  --[ InitD_OOBFlag( '1' ), InitDOOB1( ) ]->
   [
   !Pairing( InitD, ResD ),
   Out( <MacAddI, MacAddR, InitD, 'Req', IOCapabilityI, '1', MITMI, '16'> ),
   InitDReqPairing( InitD, MacAddI, IOCapabilityI, '1', MITMI, ResD,
                    MacAddR, ~skI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDSResponseWithOOBflagR1[color=#fff68f]:
   [
   In( <MacAddI, MacAddR, InitD, 'Req', IOCapabilityI, OOBflagI, MITMI, 
        KeySizeInit>
   ),
   !Device( ResD, MacAddR, IOCapabilityR, OOBCapabilityR, MITMR, ~skR,
            'Responder'
   ),
   !State_ResD_RevOOBInfo( MacAddI, ra, Ca )
   ]
  --[ AFResDOnlyOneThread( ), ResD_OOBFlag( '1' ), ResDOOB1( ) ]->
   [
   !Pairing( InitD, ResD ),
   ResDStartPairing( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                     IOCapabilityR, '1', MITMR, ~skR
   ),
   Out( <MacAddR, MacAddI, 'response', IOCapabilityR, '1', MITMR, '16'> ),
   !InitDKeySize( KeySizeInit )
   ]

  /* has exactly the trivial AC variant */

restriction OOBCapToOOBFlagInitD:
  "∀ #i #j.
    ((ResDOOBOut( '1' ) @ #i) ∧ (InitDOOBIn( '1' ) @ #j)) ⇒
    (∃ #k. InitDOOB1( ) @ #k)"

restriction OOBCapToOOBFlagResD:
  "∀ #i #j.
    ((InitDOOBOut( '1' ) @ #i) ∧ (ResDOOBIn( '1' ) @ #j)) ⇒
    (∃ #k. ResDOOB1( ) @ #k)"

rule (modulo E) InitDStartPairing[color=#bbffff]:
   [
   In( <MacAddR, MacAddI, 'response', IOCapabilityR, OOBflagR, MITMR, 
        KeySizeRes>
   ),
   InitDReqPairing( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, ResD,
                    MacAddR, ~skI
   )
   ]
  -->
   [
   InitDStartPairing( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI
   ),
   !ResDKeySize( KeySizeRes )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitDSendDH[color=#bbffff]:
   [
   InitDStartPairing( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI
   )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, 'g'^~skI> ),
   InitDSentDH( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                IOCapabilityR, OOBflagR, MITMR, ~skI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDRecDHSendDH[color=#fff68f]:
   [
   ResDStartPairing( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                     IOCapabilityR, OOBflagR, MITMR, ~skR
   ),
   In( <MacAddI, MacAddR, DHpkI> )
   ]
  --[ Running_Res( MacAddR, MacAddI, <'DHKey', DHpkI^~skR> ) ]->
   [
   Out( <MacAddR, MacAddI, 'g'^~skR> ),
   ResDDHKey( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
              IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHpkI^~skR
   )
   ]

  /*
  rule (modulo AC) ResDRecDHSendDH[color=#fff68f]:
     [
     ResDStartPairing( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                       IOCapabilityR, OOBflagR, MITMR, ~skR
     ),
     In( <MacAddI, MacAddR, DHpkI> )
     ]
    --[ Running_Res( MacAddR, MacAddI, <'DHKey', z> ) ]->
     [
     Out( <MacAddR, MacAddI, 'g'^~skR> ),
     ResDDHKey( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, z
     )
     ]
    variants (modulo AC)
    1. ~skR  = ~skR.16
       DHpkI = DHpkI.17
       z     = DHpkI.17^~skR.16
    
    2. ~skR  = ~skR.27
       DHpkI = z.39^inv(~skR.27)
       z     = z.39
    
    3. ~skR  = ~skR.82
       DHpkI = x.161^x.162
       z     = x.161^(~skR.82*x.162)
    
    4. ~skR  = ~skR.83
       DHpkI = x.163^inv((~skR.83*x.164))
       z     = x.163^inv(x.164)
    
    5. ~skR  = ~skR.83
       DHpkI = x.163^(x.164*inv(~skR.83))
       z     = x.163^x.164
    
    6. ~skR  = ~skR.84
       DHpkI = x.164^(x.165*inv((~skR.84*x.166)))
       z     = x.164^(x.165*inv(x.166))
  */

rule (modulo E) InitDRevDH[color=#bbffff]:
   [
   InitDSentDH( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                IOCapabilityR, OOBflagR, MITMR, ~skI
   ),
   In( <MacAddR, MacAddI, DHpkR> )
   ]
  --[ Running_Init( MacAddI, MacAddR, <'DHKey', DHpkR^~skI> ) ]->
   [
   InitDDHKey( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
               IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHpkR^~skI
   )
   ]

  /*
  rule (modulo AC) InitDRevDH[color=#bbffff]:
     [
     InitDSentDH( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI
     ),
     In( <MacAddR, MacAddI, DHpkR> )
     ]
    --[ Running_Init( MacAddI, MacAddR, <'DHKey', z> ) ]->
     [
     InitDDHKey( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, z
     )
     ]
    variants (modulo AC)
    1. ~skI  = ~skI.14
       DHpkR = DHpkR.15
       z     = DHpkR.15^~skI.14
    
    2. ~skI  = ~skI.15
       DHpkR = z.26^inv(~skI.15)
       z     = z.26
    
    3. ~skI  = ~skI.16
       DHpkR = x.28^x.29
       z     = x.28^(~skI.16*x.29)
    
    4. ~skI  = ~skI.16
       DHpkR = x.29^inv((~skI.16*x.30))
       z     = x.29^inv(x.30)
    
    5. ~skI  = ~skI.16
       DHpkR = x.29^(x.30*inv(~skI.16))
       z     = x.29^x.30
    
    6. ~skI  = ~skI.17
       DHpkR = x.30^(x.31*inv((~skI.17*x.32)))
       z     = x.30^(x.31*inv(x.32))
  */

rule (modulo E) JW_ResDCommitment_NoMITMSet[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, IOCapabilityI, '0', '0', MacAddR,
              IOCapabilityR, '0', '0', ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, IOCapabilityI, '0', '0',
                                 MacAddR, IOCapabilityR, '0', '0', ~skR, DHpkI, DHKeyR, '0', '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoMITMSet[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, IOCapabilityI, '0', '0', MacAddR,
               IOCapabilityR, '0', '0', ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, IOCapabilityI, '0', '0',
                             MacAddR, IOCapabilityR, '0', '0', ~skI, DHpkR, DHKeyI, '0', '0', ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

restriction NoMITMSetJW:
  "∀ #i #j.
    ((AFMITMI( '0' ) @ #i) ∧ (AFMITMR( '0' ) @ #j)) ⇒
    (∃ #m #n. (InitDJW( ) @ #m) ∧ (ResDJW( ) @ #n))"

rule (modulo E) JW_ResDCommitment_DisplayOnly_DisplayOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
              'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayOnly', '0', MITMI,
                                 MacAddR, 'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_DisplayYesNo_DisplayOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
              'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayYesNo', '0', MITMI,
                                 MacAddR, 'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_NoInputNoOutput_DisplayOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
              'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'NoInputNoOutput', '0',
                                 MITMI, MacAddR, 'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0',
                                 ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_DisplayOnly_DisplayYesNo[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
              'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayOnly', '0', MITMI,
                                 MacAddR, 'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_NoInputNoOutput_DisplayYesNo[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
              'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'NoInputNoOutput', '0',
                                 MITMI, MacAddR, 'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_NoInputNoOutput_KeyboardOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
              'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'NoInputNoOutput', '0',
                                 MITMI, MacAddR, 'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_DisplayOnly_NoInputNoOutput[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
              'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayOnly', '0', MITMI,
                                 MacAddR, 'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0',
                                 ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_DisplayYesNo_NoInputNoOutput[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
              'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayYesNo', '0', MITMI,
                                 MacAddR, 'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0',
                                 ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_KeyboardOnly_NoInputNoOutput[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
              'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'KeyboardOnly', '0', MITMI,
                                 MacAddR, 'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0',
                                 ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_NoInputNoOutput_NoInputNoOutput[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
              'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'NoInputNoOutput', '0',
                                 MITMI, MacAddR, 'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_KeyboardDisplay_NoInputNoOutput[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
              'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'KeyboardDisplay', '0',
                                 MITMI, MacAddR, 'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_NoInputNoOutput_KeyboardDisplay[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
              'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'NoInputNoOutput', '0',
                                 MITMI, MacAddR, 'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_DisplayOnly_DisplayOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
               'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayOnly', '0', MITMI,
                             MacAddR, 'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_DisplayYesNo_DisplayOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
               'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayYesNo', '0', MITMI,
                             MacAddR, 'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoInputNoOutput_DisplayOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
               'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI,
                             MacAddR, 'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_DisplayOnly_DisplayYesNo[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
               'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayOnly', '0', MITMI,
                             MacAddR, 'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoInputNoOutput_DisplayYesNo[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
               'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI,
                             MacAddR, 'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoInputNoOutput_KeyboardOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
               'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI,
                             MacAddR, 'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_DisplayOnly_NoInputNoOutput[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
               'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayOnly', '0', MITMI,
                             MacAddR, 'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_DisplayYesNo_NoInputNoOutput[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
               'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayYesNo', '0', MITMI,
                             MacAddR, 'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_KeyboardOnly_NoInputNoOutput[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
               'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'KeyboardOnly', '0', MITMI,
                             MacAddR, 'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoInputNoOutput_NoInputNoOutput[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
               'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI,
                             MacAddR, 'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_KeyboardDisplay_NoInputNoOutput[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
               'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI,
                             MacAddR, 'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoInputNoOutput_KeyboardDisplay[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
               'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI,
                             MacAddR, 'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDSendNonce[color=#fff68f]:
   [
   JW_State_Res_Sent_Commitment( ResD, MacAddI, IOCapabilityI, OOBflagI,
                                 MITMI, MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra,
                                 rb, ~Nb
   ),
   In( <MacAddI, MacAddR, Na> )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, ~Nb> ),
   JW_State_Res_Checked( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                         ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDCheck[color=#bbffff]:
   [
   JW_State_Init_Sent_Nonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                             ~Na, Cb
   ),
   In( <MacAddR, MacAddI, Nb> )
   ]
  --[ Eq( Cb, f4(DHpkR, 'g'^~skI, Nb, '0') ) ]->
   [
   JW_State_Init_Checked( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                          ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDOK[color=#fff68f]:
   [
   JW_State_Res_Checked( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                         ~Nb
   )
   ]
  -->
   [
   State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDOk[color=#bbffff]:
   [
   JW_State_Init_Checked( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                          ~Na, Nb
   )
   ]
  -->
   [
   State_Init_OK( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDCommitment_DisplayYesNo_DisplayYesNo[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
              'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   NC_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayYesNo', '0', MITMI,
                                 MacAddR, 'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDCommitment_KeyboardDisplay_DisplayYesNo[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
              'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   NC_State_Res_Sent_Commitment( ResD, MacAddI, 'KeyboardDisplay', '0',
                                 MITMI, MacAddR, 'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDCommitment_DisplayYesNo_KeyboardDisplay[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
              'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   NC_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayYesNo', '0', MITMI,
                                 MacAddR, 'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0',
                                 ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDCommitment_KeyboardDisplay_KeyboardDisplay[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
              'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   NC_State_Res_Sent_Commitment( ResD, MacAddI, 'KeyboardDisplay', '0',
                                 MITMI, MacAddR, 'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitDSendNonce_DisplayYesNo_DisplayYesNo[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
               'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   NC_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayYesNo', '0', MITMI,
                             MacAddR, 'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitDSendNonce_KeyboardDisplay_DisplayYesNo[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
               'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   NC_State_Init_Sent_Nonce( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI,
                             MacAddR, 'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitDSendNonce_DisplayYesNo_KeyboardDisplay[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
               'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   NC_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayYesNo', '0', MITMI,
                             MacAddR, 'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitDSendNonce_KeyboardDisplay_KeyboardDisplay[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
               'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   NC_State_Init_Sent_Nonce( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI,
                             MacAddR, 'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDSendNonceDisplay[color=#fff68f]:
   [
   NC_State_Res_Sent_Commitment( ResD, MacAddI, IOCapabilityI, OOBflagI,
                                 MITMI, MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra,
                                 rb, ~Nb
   ),
   In( <MacAddI, MacAddR, Na> )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, ~Nb> ),
   Out_A( <'DisplayConfirm', 'Device', 'User'>, ResD, $User,
          g2(DHpkI, 'g'^~skR, Na, ~Nb)
   ),
   NC_State_Res_Displayed( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                           ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitCheckDisplay[color=#bbffff]:
   [
   NC_State_Init_Sent_Nonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                             ~Na, Cb
   ),
   In( <MacAddR, MacAddI, Nb> )
   ]
  --[ Eq( Cb, f4(DHpkR, 'g'^~skI, Nb, '0') ) ]->
   [
   Out_A( <'DisplayConfirm', 'Device', 'User'>, InitD, $User,
          g2('g'^~skI, DHpkR, ~Na, Nb)
   ),
   NC_State_Init_Displayed( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                            ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDOK[color=#fff68f]:
   [
   NC_State_Res_Displayed( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                           ~Nb
   ),
   In_A( <'Confirm', 'User', 'Device'>, $User, ResD, 'T' )
   ]
  --[ ResDNC( ) ]->
   [
   State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitDOk[color=#bbffff]:
   [
   NC_State_Init_Displayed( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                            ~Na, Nb
   ),
   In_A( <'Confirm', 'User', 'Device'>, $User, InitD, 'T' )
   ]
  --[ InitDNC( ) ]->
   [
   State_Init_OK( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDDisplay_DisplayOnly_KeyboardOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
               'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, InitD, $User, ~r ),
   PE_InitDDisplayed( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
                      'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDDisplay_DisplayYesNo_KeyboardOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
               'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, InitD, $User, ~r ),
   PE_InitDDisplayed( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
                      'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDDisplay_KeyboardDisplay_KeyboardOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
               'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, InitD, $User, ~r ),
   PE_InitDDisplayed( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI,
                      MacAddR, 'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDDisplay_DisplayOnly_KeyboardDisplay[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
               'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, InitD, $User, ~r ),
   PE_InitDDisplayed( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
                      'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDAskforInput_KeyboardOnly_DisplayOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
               'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, InitD, $User, 'Input' ),
   PE_InitDWaitInput( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                      'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDAskforInput_KeyboardDisplay_DisplayOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
               'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, InitD, $User, 'Input' ),
   PE_InitDWaitInput( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI,
                      MacAddR, 'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDAskforInput_KeyboardOnly_DisplayYesNo[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
               'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, InitD, $User, 'Input' ),
   PE_InitDWaitInput( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                      'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDAskforInput_KeyboardOnly_KeyboardOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
               'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, InitD, $User, 'Input' ),
   PE_InitDWaitInput( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                      'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDAskforInput_KeyboardOnly_KeyboardDisplay[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
               'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, InitD, $User, 'Input' ),
   PE_InitDWaitInput( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                      'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDDisplay_KeyboardOnly_DisplayOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
              'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, ResD, $User, ~r ),
   PE_ResDDisplayed( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                     'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDDisplay_KeyboardDisplay_DisplayOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
              'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, ResD, $User, ~r ),
   PE_ResDDisplayed( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
                     'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDDisplay_KeyboardOnly_DisplayYesNo[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
              'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, ResD, $User, ~r ),
   PE_ResDDisplayed( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                     'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDDisplay_KeyboardOnly_KeyboardDisplay[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
              'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, ResD, $User, ~r ),
   PE_ResDDisplayed( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                     'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDAskforInput_DisplayOnly_KeyboardOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
              'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input' ),
   PE_ResDWaitInput( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
                     'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDAskforInput_DisplayYesNo_KeyboardOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
              'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input' ),
   PE_ResDWaitInput( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
                     'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDAskforInput_KeyboardOnly_KeyboardOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
              'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input' ),
   PE_ResDWaitInput( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                     'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDAskforInput_KeyboardDisplay_KeyboardOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
              'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input' ),
   PE_ResDWaitInput( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
                     'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDAskforInput_DisplayOnly_KeyboardDisplay[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
              'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input' ),
   PE_ResDWaitInput( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
                     'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDUserInputInjectSecret[color=#fff68f]:
   [
   PE_ResDWaitInput( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                     IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR
   ),
   In_A( <'Input', 'User', 'Device'>, $User, ResD, r )
   ]
  -->
   [
   PE_ResDInjectSecret( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                        MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, r, r
   ),
   Out( <MacAddR, MacAddI, 'KeypressNotification'> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDUserInputInjectSecret[color=#bbffff]:
   [
   PE_InitDWaitInput( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI
   ),
   In_A( <'Input', 'User', 'Device'>, $User, InitD, r )
   ]
  -->
   [
   PE_InitDInjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, r, r
   ),
   Out( <MacAddI, MacAddR, 'KeypressNotification'> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDUserOKInjectSecret[color=#bbffff]:
   [
   PE_InitDDisplayed( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ~r
   ),
   In( <MacAddR, MacAddI, 'KeypressNotification'> )
   ]
  -->
   [
   PE_InitDInjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ~r, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDUserOKInjectSecret[color=#fff68f]:
   [
   PE_ResDDisplayed( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                     IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ~r
   ),
   In( <MacAddI, MacAddR, 'KeypressNotification'> )
   ]
  -->
   [
   PE_ResDInjectSecret( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                        MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ~r, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDCommitment[color=#bbffff]:
   [
   PE_InitDInjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb
   ),
   Fr( ~Na )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, f4('g'^~skI, DHpkR, ~Na, ra)> ),
   PE_InitDSentCommitment( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDCommitment[color=#fff68f]:
   [
   PE_ResDInjectSecret( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                        MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb
   ),
   In( <MacAddI, MacAddR, Ca> ), Fr( ~Nb )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, rb)> ),
   PE_ResDSentCommitment( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb,
                          ~Nb, Ca
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDSendNonce[color=#bbffff]:
   [
   PE_InitDSentCommitment( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na
   ),
   In( <MacAddR, MacAddI, Cb> )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   PE_InitDSentNonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                      ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDCheckSendNonceOK[color=#fff68f]:
   [
   PE_ResDSentCommitment( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb,
                          ~Nb, Ca
   ),
   In( <MacAddI, MacAddR, Na> )
   ]
  --[ Eq( Ca, f4(DHpkI, 'g'^~skR, Na, rb) ), ResDPE( ) ]->
   [
   Out( <MacAddR, MacAddI, ~Nb> ),
   State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDCheckOK[color=#bbffff]:
   [
   PE_InitDSentNonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                      ~Na, Cb
   ),
   In( <MacAddR, MacAddI, Nb> )
   ]
  --[ Eq( Cb, f4(DHpkR, 'g'^~skI, Nb, ra) ), InitDPE( ) ]->
   [
   State_Init_OK( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) User_NC[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'DisplayConfirm', 'Device', 'User'>, D1, User, m ),
   In_A( <'DisplayConfirm', 'Device', 'User'>, D2, User, m )
   ]
  --[ AFOneInteraction( ) ]->
   [
   Out_A( <'Confirm', 'User', 'Device'>, User, D1, 'T' ),
   Out_A( <'Confirm', 'User', 'Device'>, User, D2, 'T' )
   ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

rule (modulo E) User_PE_0[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'AskforInput', 'Device', 'User'>, D1, User, 'Input' ),
   In_A( <'AskforInput', 'Device', 'User'>, D2, User, 'Input' ),
   Fr( ~passkey )
   ]
  --[ AFOneInteraction( ) ]->
   [
   Out_A( <'Input', 'User', 'Device'>, User, D1, ~passkey ),
   Out_A( <'Input', 'User', 'Device'>, User, D2, ~passkey )
   ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

rule (modulo E) User_PE_1[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'Display', 'Device', 'User'>, D1, User, m ),
   In_A( <'AskforInput', 'Device', 'User'>, D2, User, 'Input' )
   ]
  --[ AFOneInteraction( ) ]->
   [ Out_A( <'Input', 'User', 'Device'>, User, D2, m ) ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

rule (modulo E) User_PE_2[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'AskforInput', 'Device', 'User'>, D1, User, 'Input' ),
   In_A( <'Display', 'Device', 'User'>, D2, User, m )
   ]
  --[ AFOneInteraction( ) ]->
   [ Out_A( <'Input', 'User', 'Device'>, User, D1, m ) ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

rule (modulo E) User_UnderAttack_1[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'AskforInput', 'Device', 'User'>, D1, User, 'Input' ),
   In_A( <'DisplayConfirm', 'Device', 'User'>, D2, User, m )
   ]
  --[ AFOneInteraction( ) ]->
   [
   Out_A( <'Input', 'User', 'Device'>, User, D1, m ),
   Out_A( <'Confirm', 'User', 'Device'>, User, D2, 'T' )
   ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

rule (modulo E) User_UnderAttack_2[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'DisplayConfirm', 'Device', 'User'>, D1, User, m ),
   In_A( <'AskforInput', 'Device', 'User'>, D2, User, 'Input' )
   ]
  --[ AFOneInteraction( ) ]->
   [
   Out_A( <'Confirm', 'User', 'Device'>, User, D1, 'T' ),
   Out_A( <'Input', 'User', 'Device'>, User, D2, m )
   ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

restriction OneInteraction:
  "∀ #i #j.
    ((AFOneInteraction( ) @ #i) ∧ (AFOneInteraction( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) OOB_InitDInjectSecretsWithOOBflagR0I1[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
               IOCapabilityR, '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   !State_InitD_RevOOBInfo( MacAddR, rb, Cb )
   ]
  --[ Eq( Cb, f4(DHpkR, DHpkR, rb, '0') ) ]->
   [
   State_InitD_InjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, '0', MITMR, ~skI, DHpkR, DHKeyI, '0', rb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_InitDInjectSecretsWithOOBflagR1I0[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
               IOCapabilityR, '1', MITMR, ~skI, DHpkR, DHKeyI
   ),
   !State_InitD_SentOOBInfo( ra, Ca )
   ]
  -->
   [
   State_InitD_InjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, '1', MITMR, ~skI, DHpkR, DHKeyI, ra, '0'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_InitDInjectSecretsWithOOBflagR1I1[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
               IOCapabilityR, '1', MITMR, ~skI, DHpkR, DHKeyI
   ),
   !State_InitD_RevOOBInfo( MacAddR, rb, Cb ),
   !State_InitD_SentOOBInfo( ra, Ca )
   ]
  --[ Eq( Cb, f4(DHpkR, DHpkR, rb, '0') ) ]->
   [
   State_InitD_InjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, '1', MITMR, ~skI, DHpkR, DHKeyI, ra, rb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_ResDInjectSecretsWithOOBflagI0R1[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, IOCapabilityI, '0', MITMI, MacAddR,
              IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR
   ),
   !State_ResD_RevOOBInfo( MacAddI, ra, Ca )
   ]
  --[ Eq( Ca, f4(DHpkI, DHpkI, ra, '0') ) ]->
   [
   State_ResD_InjectSecret( ResD, MacAddI, IOCapabilityI, '0', MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, '0'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_ResDInjectSecretsWithOOBflagI1R0[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, IOCapabilityI, '1', MITMI, MacAddR,
              IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR
   ),
   !State_ResD_SentOOBInfo( rb, Cb )
   ]
  -->
   [
   State_ResD_InjectSecret( ResD, MacAddI, IOCapabilityI, '1', MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, '0', rb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_ResDInjectSecretsWithOOBflagI1R1[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, IOCapabilityI, '1', MITMI, MacAddR,
              IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR
   ),
   !State_ResD_RevOOBInfo( MacAddI, ra, Ca ),
   !State_ResD_SentOOBInfo( rb, Cb )
   ]
  --[ Eq( Ca, f4(DHpkI, DHpkI, ra, '0') ) ]->
   [
   State_ResD_InjectSecret( ResD, MacAddI, IOCapabilityI, '1', MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_InitDSendNonce[color=#bbffff]:
   [
   State_InitD_InjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb
   ),
   Fr( ~Na )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   OOB_InitDSentNonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                       MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_ResDOK[color=#fff68f]:
   [
   In( <MacAddI, MacAddR, Na> ),
   State_ResD_InjectSecret( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb
   ),
   Fr( ~Nb )
   ]
  --[ ResDOOB( ) ]->
   [
   Out( <MacAddR, MacAddI, ~Nb> ),
   State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_InitDOK[color=#bbffff]:
   [
   In( <MacAddR, MacAddI, Nb> ),
   OOB_InitDSentNonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                       MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na
   )
   ]
  --[ InitDOOB( ) ]->
   [
   State_Init_OK( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitDSendEa[color=#bbffff]:
   [
   !ResDKeySize( KeySizeRes ),
   State_Init_OK( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb
   )
   ]
  --[
  Running_Init( MacAddI, MacAddR,
                <'LTK', resize(snd(f5(DHKeyI, ~Na, Nb, MacAddI, MacAddR)), KeySizeRes)>
  ),
  SecLTK( resize(snd(f5(DHKeyI, ~Na, Nb, MacAddI, MacAddR)), KeySizeRes) )
  ]->
   [
   Out( <MacAddI, MacAddR, 
         f6(fst(f5(DHKeyI, ~Na, Nb, MacAddI, MacAddR)), ~Na, Nb, rb,
            IOCapabilityI, MacAddI, MacAddR)
        >
   ),
   InitDSentEa( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                fst(f5(DHKeyI, ~Na, Nb, MacAddI, MacAddR)),
                resize(snd(f5(DHKeyI, ~Na, Nb, MacAddI, MacAddR)), KeySizeRes)
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDSendEb[color=#fff68f]:
   [
   !InitDKeySize( KeySizeInit ),
   State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
   ),
   In( <MacAddI, MacAddR, Ea> )
   ]
  --[
  Running_Res( MacAddR, MacAddI,
               <'LTK', resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)>
  ),
  SecLTK( resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)
  ),
  Eq( Ea,
      f6(fst(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), Na, ~Nb, rb,
         IOCapabilityI, MacAddI, MacAddR)
  ),
  Commit_Res( MacAddR, MacAddI,
              <'LTK', resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)>
  ),
  Commit_Res( MacAddR, MacAddI, <'DHKey', DHKeyR> ), FinishedRes( ),
  MP( MacAddI, MacAddR ),
  LTK( MacAddR, MacAddI,
       resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)
  ),
  FSecAuthLTK( MacAddR, MacAddI,
               resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)
  )
  ]->
   [
   Out( <MacAddR, MacAddI, 
         f6(fst(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), ~Nb, Na, ra,
            IOCapabilityR, MacAddR, MacAddI)
        >
   ),
   State_ResDAuthSta2_End( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                           ~Nb, resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitDCheck[color=#bbffff]:
   [
   InitDSentEa( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                MacKeyI, LTKI
   ),
   In( <MacAddR, MacAddI, Eb> )
   ]
  --[
  Eq( Eb, f6(MacKeyI, Nb, ~Na, ra, IOCapabilityR, MacAddR, MacAddI) ),
  Commit_Init( MacAddI, MacAddR, <'LTK', LTKI> ),
  Commit_Init( MacAddI, MacAddR, <'DHKey', DHKeyI> ), FinishedInit( ),
  MP( MacAddI, MacAddR ), LTK( MacAddI, MacAddR, LTKI ),
  FSecAuthLTK( MacAddI, MacAddR, LTKI )
  ]->
   [
   State_InitDAuthSta2_End( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                            ~Na, Nb, MacKeyI, LTKI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDDistribution[color=#fff68f]:
   [
   State_ResDAuthSta2_End( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                           ~Nb, LTKR
   ),
   Fr( ~IRKR ), Fr( ~BD_ADDRR ), Fr( ~CSRKR )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, senc(<~IRKR, ~BD_ADDRR, ~CSRKR>, LTKR)> ),
   State_ResDDistributed( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                          ~Nb, LTKR, ~IRKR, ~BD_ADDRR, ~CSRKR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitDDistribution[color=#bbffff]:
   [
   State_InitDAuthSta2_End( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                            ~Na, Nb, MacKeyI, LTKI
   ),
   In( <MacAddR, MacAddI, senc(<IRKR, BD_ADDRR, CSRKR>, LTKI)> ),
   Fr( ~IRKI ), Fr( ~BD_ADDRI ), Fr( ~CSRKI )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, senc(<~IRKI, ~BD_ADDRI, ~CSRKI>, LTKI)> ),
   State_InitDDistributedBoth( InitD, MacAddI, IOCapabilityI, OOBflagI,
                               MITMI, MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra,
                               rb, ~Na, Nb, MacKeyI, LTKI, ~IRKI, ~BD_ADDRI, ~CSRKI, IRKR, BD_ADDRR,
                               CSRKR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDRecDisI[color=#fff68f]:
   [
   State_ResDDistributed( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                          ~Nb, LTKR, ~IRKR, ~BD_ADDRR, ~CSRKR
   ),
   In( <MacAddI, MacAddR, senc(<IRKI, BD_ADDRI, CSRKI>, LTKR)> )
   ]
  --[ Sec( IRKI ) ]->
   [
   State_ResDDistributedBoth( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                              MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                              ~Nb, LTKR, IRKI, BD_ADDRI, CSRKI, ~IRKR, ~BD_ADDRR, ~CSRKR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) oracle[color=#ffff00]:
   [ In( senc(m, resize(key, '7')) ) ] --> [ Out( resize(key, '7') ) ]

  /* has exactly the trivial AC variant */

restriction OnlyoneUser:
  "∀ #i #j. ((OnlyoneUser( ) @ #i) ∧ (OnlyoneUser( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction Equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction Inequality:
  "∀ x #i. (Neq( x, x ) @ #i) ⇒ (⊥)"
  // safety formula

restriction unique:
  "∀ x #i #j. ((Unique( x ) @ #i) ∧ (Unique( x ) @ #j)) ⇒ (#i = #j)"
  // safety formula

lemma Executability:
  exists-trace
  "(((((((((((((((((((((((((((((((((((((((((((∃ #i #j.
                                               (FinishedInit( ) @ #i) ∧ (FinishedRes( ) @ #j)) ∧
                                             (∀ #m #n.
                                               ((InitD_OOBFlag( '1' ) @ #m) ∧ (ResD_OOBFlag( '0' ) @ #n)) ⇒
                                               (∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)))) ∧
                                            (∀ #m #n.
                                              ((InitD_OOBFlag( '0' ) @ #m) ∧ (ResD_OOBFlag( '1' ) @ #n)) ⇒
                                              (∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)))) ∧
                                           (∀ #m #n.
                                             ((InitD_OOBFlag( '1' ) @ #m) ∧ (ResD_OOBFlag( '1' ) @ #n)) ⇒
                                             (∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)))) ∧
                                          (∀ #m #n #s #t.
                                            ((((InitD_OOBFlag( '0' ) @ #s) ∧ (ResD_OOBFlag( '0' ) @ #t)) ∧
                                              (AFMITMI( '0' ) @ #m)) ∧
                                             (AFMITMR( '0' ) @ #n)) ⇒
                                            (∃ #p #q. (InitDJW( ) @ #p) ∧ (ResDJW( ) @ #q)))) ∧
                                         (∀ #m #n #r #s.
                                           ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                                (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                               (InitD_OOBFlag( '0' ) @ #r)) ∧
                                              (ResD_OOBFlag( '0' ) @ #s)) ∧
                                             (AFMITMI( '1' ) @ #m)) ∧
                                            (AFMITMR( '0' ) @ #n)) ⇒
                                           (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                        (∀ #m #n #r #s.
                                          ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                               (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                              (InitD_OOBFlag( '0' ) @ #r)) ∧
                                             (ResD_OOBFlag( '0' ) @ #s)) ∧
                                            (AFMITMI( '0' ) @ #m)) ∧
                                           (AFMITMR( '1' ) @ #n)) ⇒
                                          (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                       (∀ #m #n #r #s.
                                         ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                              (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                             (InitD_OOBFlag( '0' ) @ #r)) ∧
                                            (ResD_OOBFlag( '0' ) @ #s)) ∧
                                           (AFMITMI( '1' ) @ #m)) ∧
                                          (AFMITMR( '1' ) @ #n)) ⇒
                                         (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                      (∀ #m #n #r #s.
                                        ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                             (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                            (InitD_OOBFlag( '0' ) @ #r)) ∧
                                           (ResD_OOBFlag( '0' ) @ #s)) ∧
                                          (AFMITMI( '1' ) @ #m)) ∧
                                         (AFMITMR( '0' ) @ #n)) ⇒
                                        (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                     (∀ #m #n #r #s.
                                       ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                            (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                           (InitD_OOBFlag( '0' ) @ #r)) ∧
                                          (ResD_OOBFlag( '0' ) @ #s)) ∧
                                         (AFMITMI( '0' ) @ #m)) ∧
                                        (AFMITMR( '1' ) @ #n)) ⇒
                                       (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                    (∀ #m #n #r #s.
                                      ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                           (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                          (InitD_OOBFlag( '0' ) @ #r)) ∧
                                         (ResD_OOBFlag( '0' ) @ #s)) ∧
                                        (AFMITMI( '1' ) @ #m)) ∧
                                       (AFMITMR( '1' ) @ #n)) ⇒
                                      (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                   (∀ #m #n #r #s.
                                     ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                          (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                         (InitD_OOBFlag( '0' ) @ #r)) ∧
                                        (ResD_OOBFlag( '0' ) @ #s)) ∧
                                       (AFMITMI( '1' ) @ #m)) ∧
                                      (AFMITMR( '0' ) @ #n)) ⇒
                                     (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                  (∀ #m #n #r #s.
                                    ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                         (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                        (InitD_OOBFlag( '0' ) @ #r)) ∧
                                       (ResD_OOBFlag( '0' ) @ #s)) ∧
                                      (AFMITMI( '0' ) @ #m)) ∧
                                     (AFMITMR( '1' ) @ #n)) ⇒
                                    (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                 (∀ #m #n #r #s.
                                   ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                        (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                       (InitD_OOBFlag( '0' ) @ #r)) ∧
                                      (ResD_OOBFlag( '0' ) @ #s)) ∧
                                     (AFMITMI( '1' ) @ #m)) ∧
                                    (AFMITMR( '1' ) @ #n)) ⇒
                                   (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                (∀ #m #n #r #s.
                                  ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                       (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                      (InitD_OOBFlag( '0' ) @ #r)) ∧
                                     (ResD_OOBFlag( '0' ) @ #s)) ∧
                                    (AFMITMI( '1' ) @ #m)) ∧
                                   (AFMITMR( '0' ) @ #n)) ⇒
                                  (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                               (∀ #m #n #r #s.
                                 ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                      (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                     (InitD_OOBFlag( '0' ) @ #r)) ∧
                                    (ResD_OOBFlag( '0' ) @ #s)) ∧
                                   (AFMITMI( '0' ) @ #m)) ∧
                                  (AFMITMR( '1' ) @ #n)) ⇒
                                 (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                              (∀ #m #n #r #s.
                                ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                     (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                    (InitD_OOBFlag( '0' ) @ #r)) ∧
                                   (ResD_OOBFlag( '0' ) @ #s)) ∧
                                  (AFMITMI( '1' ) @ #m)) ∧
                                 (AFMITMR( '1' ) @ #n)) ⇒
                                (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                             (∀ #m #n #r #s.
                               ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                                    (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                                   (InitD_OOBFlag( '0' ) @ #r)) ∧
                                  (ResD_OOBFlag( '0' ) @ #s)) ∧
                                 (AFMITMI( '1' ) @ #m)) ∧
                                (AFMITMR( '0' ) @ #n)) ⇒
                               (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                            (∀ #m #n #r #s.
                              ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                                   (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                                  (InitD_OOBFlag( '0' ) @ #r)) ∧
                                 (ResD_OOBFlag( '0' ) @ #s)) ∧
                                (AFMITMI( '0' ) @ #m)) ∧
                               (AFMITMR( '1' ) @ #n)) ⇒
                              (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                           (∀ #m #n #r #s.
                             ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                                  (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                                 (InitD_OOBFlag( '0' ) @ #r)) ∧
                                (ResD_OOBFlag( '0' ) @ #s)) ∧
                               (AFMITMI( '1' ) @ #m)) ∧
                              (AFMITMR( '1' ) @ #n)) ⇒
                             (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                          (∀ #m #n #r #s.
                            ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                 (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                                (InitD_OOBFlag( '0' ) @ #r)) ∧
                               (ResD_OOBFlag( '0' ) @ #s)) ∧
                              (AFMITMI( '1' ) @ #m)) ∧
                             (AFMITMR( '0' ) @ #n)) ⇒
                            (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                         (∀ #m #n #r #s.
                           ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                               (InitD_OOBFlag( '0' ) @ #r)) ∧
                              (ResD_OOBFlag( '0' ) @ #s)) ∧
                             (AFMITMI( '0' ) @ #m)) ∧
                            (AFMITMR( '1' ) @ #n)) ⇒
                           (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                        (∀ #m #n #r #s.
                          ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                               (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                              (InitD_OOBFlag( '0' ) @ #r)) ∧
                             (ResD_OOBFlag( '0' ) @ #s)) ∧
                            (AFMITMI( '1' ) @ #m)) ∧
                           (AFMITMR( '1' ) @ #n)) ⇒
                          (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                       (∀ #m #n #r #s.
                         ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                              (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                             (InitD_OOBFlag( '0' ) @ #r)) ∧
                            (ResD_OOBFlag( '0' ) @ #s)) ∧
                           (AFMITMI( '1' ) @ #m)) ∧
                          (AFMITMR( '0' ) @ #n)) ⇒
                         (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                      (∀ #m #n #r #s.
                        ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                             (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                            (InitD_OOBFlag( '0' ) @ #r)) ∧
                           (ResD_OOBFlag( '0' ) @ #s)) ∧
                          (AFMITMI( '0' ) @ #m)) ∧
                         (AFMITMR( '1' ) @ #n)) ⇒
                        (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                     (∀ #m #n #r #s.
                       ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                            (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                           (InitD_OOBFlag( '0' ) @ #r)) ∧
                          (ResD_OOBFlag( '0' ) @ #s)) ∧
                         (AFMITMI( '1' ) @ #m)) ∧
                        (AFMITMR( '1' ) @ #n)) ⇒
                       (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                    (∀ #m #n #r #s.
                      ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                           (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                          (InitD_OOBFlag( '0' ) @ #r)) ∧
                         (ResD_OOBFlag( '0' ) @ #s)) ∧
                        (AFMITMI( '1' ) @ #m)) ∧
                       (AFMITMR( '0' ) @ #n)) ⇒
                      (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                   (∀ #m #n #r #s.
                     ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                          (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                         (InitD_OOBFlag( '0' ) @ #r)) ∧
                        (ResD_OOBFlag( '0' ) @ #s)) ∧
                       (AFMITMI( '0' ) @ #m)) ∧
                      (AFMITMR( '1' ) @ #n)) ⇒
                     (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                  (∀ #m #n #r #s.
                    ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                         (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                        (InitD_OOBFlag( '0' ) @ #r)) ∧
                       (ResD_OOBFlag( '0' ) @ #s)) ∧
                      (AFMITMI( '1' ) @ #m)) ∧
                     (AFMITMR( '1' ) @ #n)) ⇒
                    (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                 (∀ #m #n #r #s.
                   ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                        (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                       (InitD_OOBFlag( '0' ) @ #r)) ∧
                      (ResD_OOBFlag( '0' ) @ #s)) ∧
                     (AFMITMI( '1' ) @ #m)) ∧
                    (AFMITMR( '0' ) @ #n)) ⇒
                   (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                (∀ #m #n #r #s.
                  ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                       (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                      (InitD_OOBFlag( '0' ) @ #r)) ∧
                     (ResD_OOBFlag( '0' ) @ #s)) ∧
                    (AFMITMI( '0' ) @ #m)) ∧
                   (AFMITMR( '1' ) @ #n)) ⇒
                  (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
               (∀ #m #n #r #s.
                 ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                      (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                     (InitD_OOBFlag( '0' ) @ #r)) ∧
                    (ResD_OOBFlag( '0' ) @ #s)) ∧
                   (AFMITMI( '1' ) @ #m)) ∧
                  (AFMITMR( '1' ) @ #n)) ⇒
                 (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
              (∀ #m #n #r #s.
                ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                     (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                    (InitD_OOBFlag( '0' ) @ #r)) ∧
                   (ResD_OOBFlag( '0' ) @ #s)) ∧
                  (AFMITMI( '1' ) @ #m)) ∧
                 (AFMITMR( '0' ) @ #n)) ⇒
                (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
             (∀ #m #n #r #s.
               ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                    (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                   (InitD_OOBFlag( '0' ) @ #r)) ∧
                  (ResD_OOBFlag( '0' ) @ #s)) ∧
                 (AFMITMI( '0' ) @ #m)) ∧
                (AFMITMR( '1' ) @ #n)) ⇒
               (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
            (∀ #m #n #r #s.
              ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                   (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                  (InitD_OOBFlag( '0' ) @ #r)) ∧
                 (ResD_OOBFlag( '0' ) @ #s)) ∧
                (AFMITMI( '1' ) @ #m)) ∧
               (AFMITMR( '1' ) @ #n)) ⇒
              (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
           (∀ #m #n #r #s.
             ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                  (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                 (InitD_OOBFlag( '0' ) @ #r)) ∧
                (ResD_OOBFlag( '0' ) @ #s)) ∧
               (AFMITMI( '1' ) @ #m)) ∧
              (AFMITMR( '0' ) @ #n)) ⇒
             (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
          (∀ #m #n #r #s.
            ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                 (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                (InitD_OOBFlag( '0' ) @ #r)) ∧
               (ResD_OOBFlag( '0' ) @ #s)) ∧
              (AFMITMI( '0' ) @ #m)) ∧
             (AFMITMR( '1' ) @ #n)) ⇒
            (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
         (∀ #m #n #r #s.
           ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
               (InitD_OOBFlag( '0' ) @ #r)) ∧
              (ResD_OOBFlag( '0' ) @ #s)) ∧
             (AFMITMI( '1' ) @ #m)) ∧
            (AFMITMR( '1' ) @ #n)) ⇒
           (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
        (∀ #m #n #r #s.
          ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
               (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
              (InitD_OOBFlag( '0' ) @ #r)) ∧
             (ResD_OOBFlag( '0' ) @ #s)) ∧
            (AFMITMI( '1' ) @ #m)) ∧
           (AFMITMR( '0' ) @ #n)) ⇒
          (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
       (∀ #m #n #r #s.
         ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
              (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
             (InitD_OOBFlag( '0' ) @ #r)) ∧
            (ResD_OOBFlag( '0' ) @ #s)) ∧
           (AFMITMI( '0' ) @ #m)) ∧
          (AFMITMR( '1' ) @ #n)) ⇒
         (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
      (∀ #m #n #r #s.
        ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
             (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
            (InitD_OOBFlag( '0' ) @ #r)) ∧
           (ResD_OOBFlag( '0' ) @ #s)) ∧
          (AFMITMI( '1' ) @ #m)) ∧
         (AFMITMR( '1' ) @ #n)) ⇒
        (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
     (∀ #m #n #r #s.
       ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
            (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
           (InitD_OOBFlag( '0' ) @ #r)) ∧
          (ResD_OOBFlag( '0' ) @ #s)) ∧
         (AFMITMI( '1' ) @ #m)) ∧
        (AFMITMR( '0' ) @ #n)) ⇒
       (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
    (∀ #m #n #r #s.
      ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
           (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
          (InitD_OOBFlag( '0' ) @ #r)) ∧
         (ResD_OOBFlag( '0' ) @ #s)) ∧
        (AFMITMI( '0' ) @ #m)) ∧
       (AFMITMR( '1' ) @ #n)) ⇒
      (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
   (∀ #m #n #r #s.
     ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
          (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
         (InitD_OOBFlag( '0' ) @ #r)) ∧
        (ResD_OOBFlag( '0' ) @ #s)) ∧
       (AFMITMI( '1' ) @ #m)) ∧
      (AFMITMR( '1' ) @ #n)) ⇒
     (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))"
/*
guarded formula characterizing all satisfying traces:
"(∃ #i #j. (FinishedInit( ) @ #i) ∧ (FinishedRes( ) @ #j)) ∧
 (∀ #m #n.
   (InitD_OOBFlag( '1' ) @ #m) ∧ (ResD_OOBFlag( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)) ∧
 (∀ #m #n.
   (InitD_OOBFlag( '0' ) @ #m) ∧ (ResD_OOBFlag( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)) ∧
 (∀ #m #n.
   (InitD_OOBFlag( '1' ) @ #m) ∧ (ResD_OOBFlag( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)) ∧
 (∀ #m #n #s #t.
   (InitD_OOBFlag( '0' ) @ #s) ∧
   (ResD_OOBFlag( '0' ) @ #t) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDJW( ) @ #p) ∧ (ResDJW( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q))"
*/
simplify
solve( InitDSentEa( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                    MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                    ~Na, Nb, MacKeyI, LTKI
       ) ▶₀ #i )
  case InitDSendEa_case_07
  solve( !InitDKeySize( KeySizeInit ) ▶₀ #j )
    case ResDSResponse
    solve( State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR.1, IOCapabilityR, OOBflagR, MITMR.1, ~skR, DHpkI, DHKeyR, ra, rb,
                         Na.1, ~Nb.1
           ) ▶₁ #j )
      case NC_ResDOK_case_1
      solve( NC_State_Init_Displayed( InitD, MacAddI.1, IOCapabilityI,
                                      OOBflagI, MITMI.1, MacAddR.1, IOCapabilityR, OOBflagR, MITMR.1, ~skI.1,
                                      DHpkR.1, DHKeyI.1, ra, rb, ~Na.2, Nb.2
             ) ▶₀ #p )
        case NC_InitCheckDisplay
        solve( NC_State_Res_Displayed( ResD, MacAddI.1, IOCapabilityI, OOBflagI,
                                       MITMI.1, MacAddR.1, IOCapabilityR, OOBflagR, MITMR.1, ~skR.1, DHpkI.1,
                                       DHKeyR.1, ra, rb, Na.2, ~Nb.2
               ) ▶₀ #q )
          case NC_ResDSendNonceDisplay
          solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D, $User, m
                 ) ▶₂ #vr.10 )
            case receive_authenticated
            solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D.1, $User,
                         g2('g'^~skI, DHpkR, ~Na, Nb)
                   ) ▶₃ #vr.10 )
              case receive_authenticated
              solve( !KU( ~MacAdd.1 ) @ #vk.18 )
                case Advertising
                solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, MacAddR)), ~Nb,
                               ~Na, '0', 'KeyboardDisplay', MacAddR, ~MacAdd)
                       ) @ #vk.12 )
                  case ResDSendEb
                  solve( !KU( ~MacAdd ) @ #vk.12 )
                    case InitDRequest
                    solve( !KU( ~Na ) @ #vk.44 )
                      case NC_InitDSendNonce_DisplayYesNo_KeyboardDisplay
                      solve( !KU( ~Nb ) @ #vk.35 )
                        case NC_ResDSendNonceDisplay
                        solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                       ~Na, ~Nb, '0', 'DisplayYesNo', ~MacAdd, ~MacAdd.1)
                               ) @ #vk.22 )
                          case InitDSendEa
                          solve( !KU( f4('g'^~skR, 'g'^~skI, ~Nb, '0') ) @ #vk.37 )
                            case NC_ResDCommitment_DisplayYesNo_KeyboardDisplay
                            solve( !KU( 'g'^~skI ) @ #vk.45 )
                              case InitDSendDH
                              solve( !KU( 'g'^~skR ) @ #vk.39 )
                                case ResDRecDHSendDH
                                SOLVED // trace found
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

predicate: A1( a, b, dhkey )<=>∀ #i.
 (Commit_Init( a, b, <'DHKey', dhkey> ) @ #i) ⇒
 ((∃ #j. Running_Res( b, a, <'DHKey', dhkey> ) @ #j) ∨
  (∃ #k. InitDJW( ) @ #k))

predicate: A2( a, b, dhkey )<=>∀ #i.
 (Commit_Res( a, b, <'DHKey', dhkey> ) @ #i) ⇒
 ((∃ #j. Running_Init( b, a, <'DHKey', dhkey> ) @ #j) ∨
  (∃ #k. ResDJW( ) @ #k))

predicate: A3( a, b, ltk )<=>∀ #i.
 (Commit_Init( a, b, <'LTK', ltk> ) @ #i) ⇒
 ((∃ #j. Running_Res( b, a, <'LTK', ltk> ) @ #j) ∨
  (∃ #k. InitDJW( ) @ #k))

predicate: A4( a, b, ltk )<=>∀ #i.
 (Commit_Res( a, b, <'LTK', ltk> ) @ #i) ⇒
 ((∃ #j. Running_Init( b, a, <'LTK', ltk> ) @ #j) ∨
  (∃ #k. ResDJW( ) @ #k))

predicate: A5( a, b, ltk )<=>∀ #i.
 (Commit_Init( a, b, <'LTK', ltk> ) @ #i) ⇒
 (∃ #j. Running_Res( b, a, <'LTK', ltk> ) @ #j)

predicate: A6( a, b, ltk )<=>∀ #i.
 (Commit_Res( a, b, <'LTK', ltk> ) @ #i) ⇒
 (∃ #j. Running_Init( b, a, <'LTK', ltk> ) @ #j)

lemma IAuthRwithDHKey:
  all-traces
  "∀ I R DHKey #i.
    (Commit_Init( I, R, <'DHKey', DHKey> ) @ #i) ⇒
    ((∃ #j. Running_Res( R, I, <'DHKey', DHKey> ) @ #j) ∨
     (∃ #k. InitDJW( ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ I R DHKey #i.
  (Commit_Init( I, R, <'DHKey', DHKey> ) @ #i)
 ∧
  (∀ #j. (Running_Res( R, I, <'DHKey', DHKey> ) @ #j) ⇒ ⊥) ∧
  (∀ #k. (InitDJW( ) @ #k) ⇒ ⊥)"
*/
simplify
solve( Commit_Init( I, R, <'DHKey', DHKey> ) @ #i )
  case InitDCheck
  solve( InitDSentEa( InitD, I, IOCapabilityI, OOBflagI, MITMI, R,
                      IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKey, ra, rb, ~Na, Nb,
                      MacKeyI, LTKI
         ) ▶₀ #i )
    case InitDSendEa_case_05
    solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D, $User, m
           ) ▶₂ #vr.11 )
      case receive_authenticated
      solve( In_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input'
             ) ▶₃ #vr.11 )
        case receive_authenticated
        solve( !KU( ~MacAdd.1 ) @ #vk.30 )
          case Advertising
          solve( !KU( f6(fst(f5(DHKey, ~Na, Nb, ~MacAdd, R)), Nb, ~Na, '0',
                         'DisplayYesNo', R, ~MacAdd)
                 ) @ #vk.12 )
            case c_f6
            solve( !KU( fst(f5(DHKey, ~Na, Nb, ~MacAdd, R)) ) @ #vk.42 )
              case c_fst
              solve( !KU( f5(DHKey, ~Na, Nb, ~MacAdd, R) ) @ #vk.44 )
                case c_f5
                solve( !KU( f4(DHpkR, 'g'^~skI, Nb, '0') ) @ #vk.34 )
                  case c_f4
                  solve( splitEqs(1) )
                    case split_case_2
                    solve( !KU( DHpkR^~skI ) @ #vk.45 )
                      case InitDSendDH
                      solve( splitEqs(3) )
                        case split_case_2
                        solve( !KU( ~MacAdd ) @ #vk.17 )
                          case InitDRequest
                          solve( !KU( ~Na ) @ #vk.45 )
                            case NC_InitDSendNonce_DisplayYesNo_DisplayYesNo
                            SOLVED // trace found
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma RAuthIwithDHKey:
  all-traces
  "∀ I R DHKey #i.
    (Commit_Res( R, I, <'DHKey', DHKey> ) @ #i) ⇒
    ((∃ #j. Running_Init( I, R, <'DHKey', DHKey> ) @ #j) ∨
     (∃ #k. ResDJW( ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ I R DHKey #i.
  (Commit_Res( R, I, <'DHKey', DHKey> ) @ #i)
 ∧
  (∀ #j. (Running_Init( I, R, <'DHKey', DHKey> ) @ #j) ⇒ ⊥) ∧
  (∀ #k. (ResDJW( ) @ #k) ⇒ ⊥)"
*/
simplify
solve( Commit_Res( R, I, <'DHKey', DHKey> ) @ #i )
  case ResDSendEb
  solve( !InitDKeySize( KeySizeInit ) ▶₀ #i )
    case ResDSResponse
    solve( State_Res_OK( ResD, I, IOCapabilityI, OOBflagI, MITMI, R,
                         IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKey, ra, rb, Na, ~Nb
           ) ▶₁ #i )
      case PE_ResDCheckSendNonceOK_case_08
      solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D.1, $User, ra
             ) ▶₂ #vr.9 )
        case receive_authenticated_case_1
        solve( In_A( <'AskforInput', 'Device', 'User'>, $D, $User, 'Input'
               ) ▶₃ #vr.9 )
          case receive_authenticated
          solve( !KU( ~MacAdd ) @ #vk.7 )
            case Advertising
            solve( !KU( f6(fst(f5(DHKey, Na.1, ~Nb.1, I, ~MacAdd)), Na.1, ~Nb.1,
                           g2('g'^~skI, DHpkR, ~Na, Nb), 'DisplayOnly', I, ~MacAdd)
                   ) @ #vk.12 )
              case c_f6
              solve( !KU( fst(f5(DHKey, Na.1, ~Nb.1, I, ~MacAdd)) ) @ #vk.48 )
                case c_fst
                solve( !KU( g2('g'^~skI, DHpkR, ~Na, Nb) ) @ #vk.50 )
                  case c_g2
                  solve( !KU( f5(DHKey, Na.1, ~Nb.1, I, ~MacAdd) ) @ #vk.51 )
                    case c_f5
                    solve( !KU( f4(DHpkI, 'g'^~skR, Na.1, g2('g'^~skI, DHpkR, ~Na, Nb))
                           ) @ #vk.33 )
                      case c_f4
                      solve( !KU( f4(DHpkR, 'g'^~skI, Nb, '0') ) @ #vk.44 )
                        case c_f4
                        solve( splitEqs(1) )
                          case split_case_2
                          solve( !KU( DHpkI^~skR ) @ #vk.54 )
                            case ResDRecDHSendDH
                            solve( splitEqs(2) )
                              case split_case_2
                              solve( !KU( ~MacAdd.1 ) @ #vk.43 )
                                case InitDRequest
                                solve( !KU( ~Nb.1 ) @ #vk.52 )
                                  case PE_ResDCheckSendNonceOK
                                  solve( !KU( ~Na ) @ #vk.54 )
                                    case NC_InitDSendNonce_DisplayYesNo_DisplayYesNo
                                    solve( !KU( 'g'^~skI ) @ #vk.54 )
                                      case InitDSendDH
                                      SOLVED // trace found
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma IAuthRwithLTK:
  all-traces
  "∀ I R LTK #i.
    (Commit_Init( I, R, <'LTK', LTK> ) @ #i) ⇒
    ((∃ #j. Running_Res( R, I, <'LTK', LTK> ) @ #j) ∨
     (∃ #k. InitDJW( ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ I R LTK #i.
  (Commit_Init( I, R, <'LTK', LTK> ) @ #i)
 ∧
  (∀ #j. (Running_Res( R, I, <'LTK', LTK> ) @ #j) ⇒ ⊥) ∧
  (∀ #k. (InitDJW( ) @ #k) ⇒ ⊥)"
*/
simplify
solve( Commit_Init( I, R, <'LTK', LTK> ) @ #i )
  case InitDCheck
  solve( InitDSentEa( InitD, I, IOCapabilityI, OOBflagI, MITMI, R,
                      IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                      MacKeyI, LTK
         ) ▶₀ #i )
    case InitDSendEa_case_05
    solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D, $User, m
           ) ▶₂ #vr.11 )
      case receive_authenticated
      solve( In_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input'
             ) ▶₃ #vr.11 )
        case receive_authenticated
        solve( !KU( ~MacAdd.1 ) @ #vk.30 )
          case Advertising
          solve( !KU( f6(fst(f5(DHKeyI, ~Na, Nb, ~MacAdd, R)), Nb, ~Na, '0',
                         'DisplayYesNo', R, ~MacAdd)
                 ) @ #vk.12 )
            case c_f6
            solve( !KU( fst(f5(DHKeyI, ~Na, Nb, ~MacAdd, R)) ) @ #vk.42 )
              case c_fst
              solve( !KU( f5(DHKeyI, ~Na, Nb, ~MacAdd, R) ) @ #vk.44 )
                case c_f5
                solve( !KU( f4(DHpkR, 'g'^~skI, Nb, '0') ) @ #vk.34 )
                  case c_f4
                  solve( splitEqs(1) )
                    case split_case_2
                    solve( !KU( DHpkR^~skI ) @ #vk.45 )
                      case InitDSendDH
                      solve( splitEqs(3) )
                        case split_case_2
                        solve( !KU( ~MacAdd ) @ #vk.17 )
                          case InitDRequest
                          solve( !KU( ~Na ) @ #vk.45 )
                            case NC_InitDSendNonce_DisplayYesNo_DisplayYesNo
                            SOLVED // trace found
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma RAuthIwithLTK:
  all-traces
  "∀ I R LTK #i.
    (Commit_Res( I, R, <'LTK', LTK> ) @ #i) ⇒
    ((∃ #j. Running_Init( R, I, <'LTK', LTK> ) @ #j) ∨
     (∃ #k. ResDJW( ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ I R LTK #i.
  (Commit_Res( I, R, <'LTK', LTK> ) @ #i)
 ∧
  (∀ #j. (Running_Init( R, I, <'LTK', LTK> ) @ #j) ⇒ ⊥) ∧
  (∀ #k. (ResDJW( ) @ #k) ⇒ ⊥)"
*/
simplify
solve( Commit_Res( I, R, <'LTK', LTK> ) @ #i )
  case ResDSendEb
  solve( !InitDKeySize( KeySizeInit ) ▶₀ #i )
    case ResDSResponse
    solve( State_Res_OK( ResD, R, IOCapabilityI, OOBflagI, MITMI, I,
                         IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
           ) ▶₁ #i )
      case NC_ResDOK_case_02
      solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D.1, $User, m
             ) ▶₂ #vr.8 )
        case receive_authenticated_case_1
        solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D, $User,
                     g2('g'^~skI, DHpkR, ~Na.1, Nb.1)
               ) ▶₃ #vr.8 )
          case receive_authenticated
          solve( !KU( ~MacAdd ) @ #vk.6 )
            case Advertising
            solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, MacAddI, ~MacAdd)), ~Na,
                           ~Nb, '0', 'DisplayYesNo', MacAddI, ~MacAdd)
                   ) @ #vk.10 )
              case InitDSendEa
              solve( !KU( ~MacAdd ) @ #vk.11 )
                case InitDRequest
                solve( !KU( ~Na ) @ #vk.32 )
                  case NC_InitDSendNonce_DisplayYesNo_DisplayYesNo
                  solve( !KU( ~Nb ) @ #vk.35 )
                    case NC_ResDSendNonceDisplay
                    solve( !KU( f4('g'^~skR, 'g'^~skI, ~Nb, '0') ) @ #vk.36 )
                      case NC_ResDCommitment_DisplayYesNo_KeyboardDisplay
                      solve( !KU( 'g'^~skI ) @ #vk.35 )
                        case InitDSendDH
                        solve( !KU( 'g'^~skR ) @ #vk.37 )
                          case ResDRecDHSendDH
                          SOLVED // trace found
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma MITMP:
  all-traces
  "∀ I R #i.
    (MP( I, R ) @ #i) ⇒
    (¬(∃ LTKI LTKR #t1 #t2.
        (((¬(∀ #i.1.
              (Commit_Init( I, R, <'LTK', LTKI> ) @ #i.1) ⇒
              ((∃ #j. Running_Res( R, I, <'LTK', LTKI> ) @ #j) ∨
               (∃ #k. InitDJW( ) @ #k)))) ∧
          (¬(∀ #i.1.
              (Commit_Res( R, I, <'LTK', LTKR> ) @ #i.1) ⇒
              ((∃ #j. Running_Init( I, R, <'LTK', LTKR> ) @ #j) ∨
               (∃ #k. ResDJW( ) @ #k))))) ∧
         (K( LTKI ) @ #t1)) ∧
        (K( LTKR ) @ #t2)))"
/*
guarded formula characterizing all counter-examples:
"∃ I R #i.
  (MP( I, R ) @ #i)
 ∧
  ∃ LTKI LTKR #t1 #t2.
   (K( LTKI ) @ #t1) ∧ (K( LTKR ) @ #t2)
  ∧
   (∃ #i.1.
     (Commit_Init( I, R, <'LTK', LTKI> ) @ #i.1)
    ∧
     (∀ #j. (Running_Res( R, I, <'LTK', LTKI> ) @ #j) ⇒ ⊥) ∧
     (∀ #k. (InitDJW( ) @ #k) ⇒ ⊥)) ∧
   (∃ #i.1.
     (Commit_Res( R, I, <'LTK', LTKR> ) @ #i.1)
    ∧
     (∀ #j. (Running_Init( I, R, <'LTK', LTKR> ) @ #j) ⇒ ⊥) ∧
     (∀ #k. (ResDJW( ) @ #k) ⇒ ⊥))"
*/
simplify
solve( MP( I, R ) @ #i )
  case InitDCheck
  solve( InitDSentEa( InitD, I, IOCapabilityI, OOBflagI, MITMI, R,
                      IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                      MacKeyI, LTKI
         ) ▶₀ #i )
    case InitDSendEa_case_05
    solve( Commit_Init( ~MacAdd, R, <'LTK', LTKI> ) @ #i.1 )
      case InitDCheck
      solve( InitDSentEa( InitD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI, R,
                          IOCapabilityR, OOBflagR, MITMR.1, ~skI.1, DHpkR.1, DHKeyI.1, ra, rb,
                          ~Na.1, Nb.1, MacKeyI, LTKI
             ) ▶₀ #i.1 )
        case InitDSendEa
        solve( Commit_Res( R, ~MacAdd, <'LTK', LTKR> ) @ #i.1 )
          case ResDSendEb
          solve( !InitDKeySize( KeySizeInit ) ▶₀ #i.1 )
            case ResDSResponse
            solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI, R,
                                 IOCapabilityR, OOBflagR, MITMR.1, ~skR, DHpkI, DHKeyR, ra, rb, Na.1,
                                 ~Nb.1
                   ) ▶₁ #i.1 )
              case PE_ResDCheckSendNonceOK_case_1
              solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D, $User, m
                     ) ▶₂ #vr.11 )
                case receive_authenticated
                solve( In_A( <'AskforInput', 'Device', 'User'>, $D.1, $User, 'Input'
                       ) ▶₃ #vr.11 )
                  case receive_authenticated
                  solve( !KU( ~MacAdd.1 ) @ #vk.3 )
                    case Advertising
                    solve( !KU( f6(fst(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb, ~Na,
                                   '0', 'DisplayYesNo', ~MacAdd.1, ~MacAdd)
                           ) @ #vk.23 )
                      case c_f6
                      solve( !KU( fst(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)) ) @ #vk.51 )
                        case c_fst
                        solve( !KU( f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1) ) @ #vk.53 )
                          case c_f5
                          solve( !KU( f4(DHpkR, 'g'^~skI, Nb, '0') ) @ #vk.41 )
                            case c_f4
                            solve( !KU( resize(snd(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)),
                                               KeySizeRes)
                                   ) @ #vk.21 )
                              case c_resize
                              solve( !KU( snd(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)) ) @ #vk.56 )
                                case c_snd
                                solve( !KU( resize(snd(f5(DHKeyR, Na.1, ~Nb.1, ~MacAdd, ~MacAdd.1)),
                                                   KeySizeInit)
                                       ) @ #vk.23 )
                                  case c_resize
                                  solve( !KU( snd(f5(DHKeyR, Na.1, ~Nb.1, ~MacAdd, ~MacAdd.1)) ) @ #vk.57 )
                                    case c_snd
                                    solve( !KU( f5(DHKeyR, Na.1, ~Nb.1, ~MacAdd, ~MacAdd.1) ) @ #vk.58 )
                                      case c_f5
                                      solve( !KU( f6(fst(f5(DHKeyR, Na.1, ~Nb.1, ~MacAdd, ~MacAdd.1)), Na.1,
                                                     ~Nb.1, g2('g'^~skI, DHpkR, ~Na, Nb), 'DisplayOnly',
                                                     ~MacAdd, ~MacAdd.1)
                                             ) @ #vk.46 )
                                        case c_f6
                                        solve( !KU( fst(f5(DHKeyR, Na.1, ~Nb.1, ~MacAdd, ~MacAdd.1))
                                               ) @ #vk.61 )
                                          case c_fst
                                          solve( !KU( g2('g'^~skI, DHpkR, ~Na, Nb) ) @ #vk.62 )
                                            case c_g2
                                            solve( !KU( f4(DHpkI, 'g'^~skR, Na.1,
                                                           g2('g'^~skI, DHpkR, ~Na, Nb))
                                                   ) @ #vk.56 )
                                              case c_f4
                                              solve( splitEqs(1) )
                                                case split_case_2
                                                solve( !KU( DHpkR^~skI ) @ #vk.59 )
                                                  case InitDSendDH
                                                  solve( splitEqs(5) )
                                                    case split_case_2
                                                    solve( !KU( DHpkI^~skR ) @ #vk.60 )
                                                      case ResDRecDHSendDH
                                                      solve( !KU( ~MacAdd ) @ #vk.32 )
                                                        case InitDRequest
                                                        solve( !KU( ~Na ) @ #vk.59 )
                                                          case NC_InitDSendNonce_DisplayYesNo_DisplayYesNo
                                                          solve( !KU( ~Nb.1 ) @ #vk.60 )
                                                            case PE_ResDCheckSendNonceOK
                                                            SOLVED // trace found
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma LTKCP:
  all-traces
  "∀ I R LTKI LTKR #i #j.
    ((LTK( I, R, LTKI ) @ #i) ∧ (LTK( R, I, LTKR ) @ #j)) ⇒
    (¬(((¬(∀ #i.1.
            (Commit_Init( I, R, <'LTK', LTKI> ) @ #i.1) ⇒
            ((∃ #j.1. Running_Res( R, I, <'LTK', LTKI> ) @ #j.1) ∨
             (∃ #k. InitDJW( ) @ #k)))) ∧
        (¬(∀ #i.1.
            (Commit_Res( R, I, <'LTK', LTKR> ) @ #i.1) ⇒
            ((∃ #j.1. Running_Init( I, R, <'LTK', LTKR> ) @ #j.1) ∨
             (∃ #k. ResDJW( ) @ #k))))) ∧
       (¬(∃ #t1 #t2. (K( LTKI ) @ #t1) ∧ (K( LTKR ) @ #t2)))))"
/*
guarded formula characterizing all counter-examples:
"∃ I R LTKI LTKR #i #j.
  (LTK( I, R, LTKI ) @ #i) ∧ (LTK( R, I, LTKR ) @ #j)
 ∧
  (∃ #i.1.
    (Commit_Init( I, R, <'LTK', LTKI> ) @ #i.1)
   ∧
    (∀ #j.1. (Running_Res( R, I, <'LTK', LTKI> ) @ #j.1) ⇒ ⊥) ∧
    (∀ #k. (InitDJW( ) @ #k) ⇒ ⊥)) ∧
  (∃ #i.1.
    (Commit_Res( R, I, <'LTK', LTKR> ) @ #i.1)
   ∧
    (∀ #j.1. (Running_Init( I, R, <'LTK', LTKR> ) @ #j.1) ⇒ ⊥) ∧
    (∀ #k. (ResDJW( ) @ #k) ⇒ ⊥)) ∧
  (∀ #t1 #t2. (K( LTKI ) @ #t1) ∧ (K( LTKR ) @ #t2) ⇒ ⊥)"
*/
simplify
solve( LTK( I, R, LTKI ) @ #i )
  case InitDCheck
  solve( InitDSentEa( InitD, I, IOCapabilityI, OOBflagI, MITMI, R,
                      IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                      MacKeyI, LTKI
         ) ▶₀ #i )
    case InitDSendEa_case_05
    solve( LTK( R, ~MacAdd, LTKR ) @ #j )
      case ResDSendEb
      solve( !InitDKeySize( KeySizeInit ) ▶₀ #j )
        case ResDSResponse
        solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI, R,
                             IOCapabilityR, OOBflagR, MITMR.1, ~skR, DHpkI, DHKeyR, ra, rb, Na.1,
                             ~Nb.1
               ) ▶₁ #j )
          case PE_ResDCheckSendNonceOK_case_1
          solve( Commit_Init( ~MacAdd, ~MacAdd.1,
                              <'LTK', resize(snd(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)), KeySizeRes)>
                 ) @ #i.1 )
            case InitDCheck
            solve( InitDSentEa( InitD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI.1,
                                ~MacAdd.1, IOCapabilityR, OOBflagR, MITMR.1, ~skI.1, DHpkR.1, DHKeyI.1,
                                ra, rb, ~Na.2, Nb.2, MacKeyI,
                                resize(snd(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)), KeySizeRes)
                   ) ▶₀ #i.1 )
              case InitDSendEa
              solve( Commit_Res( ~MacAdd.1, ~MacAdd,
                                 <'LTK', 
                                  resize(snd(f5(DHKeyR, Na.1, ~Nb.1, ~MacAdd, ~MacAdd.1)), KeySizeInit)>
                     ) @ #i.1 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit ) ▶₀ #i.1 )
                  case ResDSResponse
                  solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR, OOBflagR, MITMR.1, ~skR.1, DHpkI.1, DHKeyR,
                                       ra, rb, Na.1, ~Nb.1
                         ) ▶₁ #i.1 )
                    case PE_ResDCheckSendNonceOK
                    solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D, $User, m
                           ) ▶₂ #vr.11 )
                      case receive_authenticated
                      solve( In_A( <'AskforInput', 'Device', 'User'>, $D.1, $User, 'Input'
                             ) ▶₃ #vr.11 )
                        case receive_authenticated
                        solve( !KU( ~MacAdd.1 ) @ #vk.1 )
                          case Advertising
                          solve( !KU( f6(fst(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb, ~Na,
                                         '0', 'DisplayYesNo', ~MacAdd.1, ~MacAdd)
                                 ) @ #vk.21 )
                            case c_f6
                            solve( !KU( fst(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)) ) @ #vk.49 )
                              case c_fst
                              solve( !KU( f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1) ) @ #vk.51 )
                                case c_f5
                                solve( !KU( f4(DHpkR, 'g'^~skI, Nb, '0') ) @ #vk.39 )
                                  case c_f4
                                  solve( !KU( f6(fst(f5(DHKeyR, Na.1, ~Nb.1, ~MacAdd, ~MacAdd.1)), Na.1,
                                                 ~Nb.1, g2('g'^~skI, DHpkR, ~Na, Nb), 'DisplayOnly', ~MacAdd,
                                                 ~MacAdd.1)
                                         ) @ #vk.41 )
                                    case c_f6
                                    solve( !KU( fst(f5(DHKeyR, Na.1, ~Nb.1, ~MacAdd, ~MacAdd.1)) ) @ #vk.54 )
                                      case c_fst
                                      solve( !KU( g2('g'^~skI, DHpkR, ~Na, Nb) ) @ #vk.56 )
                                        case c_g2
                                        solve( !KU( f5(DHKeyR, Na.1, ~Nb.1, ~MacAdd, ~MacAdd.1) ) @ #vk.57 )
                                          case c_f5
                                          solve( !KU( f4(DHpkI, 'g'^~skR, Na.1, g2('g'^~skI, DHpkR, ~Na, Nb))
                                                 ) @ #vk.52 )
                                            case c_f4
                                            solve( splitEqs(1) )
                                              case split_case_2
                                              solve( !KU( DHpkR^~skI ) @ #vk.55 )
                                                case InitDSendDH
                                                solve( splitEqs(3) )
                                                  case split_case_2
                                                  solve( !KU( DHpkI^~skR ) @ #vk.57 )
                                                    case ResDRecDHSendDH
                                                    solve( !KU( ~MacAdd ) @ #vk.28 )
                                                      case InitDRequest
                                                      solve( !KU( ~Na ) @ #vk.55 )
                                                        case NC_InitDSendNonce_DisplayYesNo_DisplayYesNo
                                                        solve( !KU( ~Nb.1 ) @ #vk.56 )
                                                          case PE_ResDCheckSendNonceOK
                                                          SOLVED // trace found
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma SecAuthLTK:
  all-traces
  "∀ I R LTK #i #j.
    ((FSecAuthLTK( I, R, LTK ) @ #i) ∧ (FSecAuthLTK( R, I, LTK ) @ #j)) ⇒
    (((∀ #i.1.
        (Commit_Init( I, R, <'LTK', LTK> ) @ #i.1) ⇒
        (∃ #j.1. Running_Res( R, I, <'LTK', LTK> ) @ #j.1)) ∧
      (∀ #i.1.
        (Commit_Res( R, I, <'LTK', LTK> ) @ #i.1) ⇒
        (∃ #j.1. Running_Init( I, R, <'LTK', LTK> ) @ #j.1))) ⇒
     (¬(∃ #k. K( LTK ) @ #k)))"
/*
guarded formula characterizing all counter-examples:
"∃ I R LTK #i #j.
  (FSecAuthLTK( I, R, LTK ) @ #i) ∧ (FSecAuthLTK( R, I, LTK ) @ #j)
 ∧
  (∀ #i.1.
    (Commit_Init( I, R, <'LTK', LTK> ) @ #i.1)
   ⇒
    ∃ #j.1. (Running_Res( R, I, <'LTK', LTK> ) @ #j.1)) ∧
  (∀ #i.1.
    (Commit_Res( R, I, <'LTK', LTK> ) @ #i.1)
   ⇒
    ∃ #j.1. (Running_Init( I, R, <'LTK', LTK> ) @ #j.1)) ∧
  (∃ #k. (K( LTK ) @ #k))"
*/
simplify
solve( FSecAuthLTK( I, R, LTK ) @ #i )
  case InitDCheck
  solve( InitDSentEa( InitD, I, IOCapabilityI, OOBflagI, MITMI, R,
                      IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                      MacKeyI, LTK
         ) ▶₀ #i )
    case InitDSendEa_case_07
    solve( FSecAuthLTK( R, ~MacAdd,
                        resize(snd(f5(DHKeyI, ~Na, Nb, ~MacAdd, R)), KeySizeRes)
           ) @ #j )
      case ResDSendEb
      solve( !InitDKeySize( KeySizeRes ) ▶₀ #j )
        case ResDSResponse
        solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI, R,
                             IOCapabilityR, OOBflagR, MITMR.1, ~skR, DHpkI, DHKeyI, ra, rb, ~Na, ~Nb
               ) ▶₁ #j )
          case NC_ResDOK_case_1
          solve( Running_Res( ~MacAdd.1, ~MacAdd,
                              <'LTK', resize(snd(f5(DHKeyI, ~Na, ~Nb, ~MacAdd, ~MacAdd.1)), KeySizeRes)
                              >
                 ) @ #j.1 )
            case ResDSendEb
            solve( !InitDKeySize( KeySizeRes ) ▶₀ #j.1 )
              case ResDSResponse
              solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI.1,
                                   ~MacAdd.1, IOCapabilityR, OOBflagR, MITMR.1, ~skR.1, DHpkI.1, DHKeyI, ra,
                                   rb, ~Na, ~Nb
                     ) ▶₁ #j.1 )
                case NC_ResDOK
                solve( Running_Init( ~MacAdd, ~MacAdd.1,
                                     <'LTK', resize(snd(f5(DHKeyI, ~Na, ~Nb, ~MacAdd, ~MacAdd.1)), KeySizeRes)
                                     >
                       ) @ #j.1 )
                  case InitDSendEa
                  solve( !ResDKeySize( KeySizeRes ) ▶₀ #j.1 )
                    case InitDStartPairing
                    solve( State_Init_OK( InitD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI.1,
                                          ~MacAdd.1, IOCapabilityR, OOBflagR, MITMR.1, ~skI.1, DHpkR.1,
                                          DHKeyI, ra, rb, ~Na, ~Nb
                           ) ▶₁ #j.1 )
                      case NC_InitDOk
                      solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D, $User, m
                             ) ▶₂ #vr.11 )
                        case receive_authenticated
                        solve( In_A( <'DisplayConfirm', 'Device', 'User'>, $D.1, $User,
                                     g2('g'^~skI, DHpkR, ~Na, ~Nb)
                               ) ▶₃ #vr.11 )
                          case receive_authenticated
                          solve( !KU( ~MacAdd.1 ) @ #vk.2 )
                            case Advertising
                            solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                      ~MacAdd.1)),
                                               KeySizeRes)
                                   ) @ #vk.1 )
                              case oracle
                              solve( !KU( senc(m,
                                               resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                                      '7'))
                                     ) @ #vk.46 )
                                case InitDDistribution
                                solve( !KU( senc(<IRKR, BD_ADDRR, CSRKR>,
                                                 resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                               ~MacAdd.1)),
                                                        '7'))
                                       ) @ #vk.49 )
                                  case ResDDistribution
                                  solve( !KU( ~MacAdd ) @ #vk.19 )
                                    case InitDRequest
                                    solve( !KU( ~Nb ) @ #vk.39 )
                                      case NC_ResDSendNonceDisplay
                                      solve( !KU( ~Na ) @ #vk.48 )
                                        case NC_InitDSendNonce_DisplayYesNo_KeyboardDisplay
                                        solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                                       ~Nb, ~Na, '0', 'KeyboardDisplay', ~MacAdd.1, ~MacAdd)
                                               ) @ #vk.26 )
                                          case ResDSendEb
                                          solve( !KU( f4('g'^~skR, 'g'^~skI, ~Nb, '0') ) @ #vk.42 )
                                            case NC_ResDCommitment_DisplayYesNo_KeyboardDisplay
                                            solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                                  ~MacAdd.1)),
                                                           ~Na, ~Nb, '0', 'DisplayYesNo', ~MacAdd, ~MacAdd.1)
                                                   ) @ #vk.44 )
                                              case InitDSendEa
                                              solve( !KU( 'g'^~skI ) @ #vk.49 )
                                                case InitDSendDH
                                                solve( !KU( 'g'^~skR ) @ #vk.45 )
                                                  case ResDRecDHSendDH
                                                  SOLVED // trace found
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.


analyzing: ./BLEResults/Unfixed/NC/BLE_SC-DisplayYesNo_KeyboardDisplay.spthy

------------------------------------------------------------------------------
analyzed: ./BLEResults/Unfixed/NC/BLE_SC-DisplayYesNo_KeyboardDisplay.spthy

  output:          ./BLEResults/Unfixed/NC/proofs/Out_All_BLE_SC-DisplayYesNo_KeyboardDisplay.spthy
  processing time: 3194.808625696s
  Executability (exists-trace): verified (18 steps)
  IAuthRwithDHKey (all-traces): falsified - found trace (16 steps)
  RAuthIwithDHKey (all-traces): falsified - found trace (21 steps)
  IAuthRwithLTK (all-traces): falsified - found trace (16 steps)
  RAuthIwithLTK (all-traces): falsified - found trace (15 steps)
  MITMP (all-traces): falsified - found trace (32 steps)
  LTKCP (all-traces): falsified - found trace (31 steps)
  SecAuthLTK (all-traces): falsified - found trace (27 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: ./BLEResults/Unfixed/NC/BLE_SC-DisplayYesNo_KeyboardDisplay.spthy

  output:          ./BLEResults/Unfixed/NC/proofs/Out_All_BLE_SC-DisplayYesNo_KeyboardDisplay.spthy
  processing time: 3194.808625696s
  Executability (exists-trace): verified (18 steps)
  IAuthRwithDHKey (all-traces): falsified - found trace (16 steps)
  RAuthIwithDHKey (all-traces): falsified - found trace (21 steps)
  IAuthRwithLTK (all-traces): falsified - found trace (16 steps)
  RAuthIwithLTK (all-traces): falsified - found trace (15 steps)
  MITMP (all-traces): falsified - found trace (32 steps)
  LTKCP (all-traces): falsified - found trace (31 steps)
  SecAuthLTK (all-traces): falsified - found trace (27 steps)

==============================================================================
