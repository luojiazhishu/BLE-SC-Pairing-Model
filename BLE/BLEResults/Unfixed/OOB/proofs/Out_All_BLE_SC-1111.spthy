theory BLE_SC_JW_NC_PE_OOB begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman
functions: f4/4, f5/5, f6/7, fst/1, g2/4, pair/2, resize/2, sdec/2,
           senc/2, snd/1
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2



rule (modulo E) send_authenticated[color=#9aff9a]:
   [ Out_A( <channelname, SendType, ReceiveType>, A, B, m ) ]
  -->
   [ Auth( <channelname, SendType, ReceiveType>, A, B, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) receive_authenticated[color=#9aff9a]:
   [ Auth( <channelname, SendType, ReceiveType>, A, B, m ) ]
  -->
   [ In_A( <channelname, SendType, ReceiveType>, A, B, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) send_OOB[color=#9aff9a]:
   [ Out_OOB( <channelname, SendType, ReceiveType>, m ) ]
  -->
   [ OOB( <channelname, SendType, ReceiveType>, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) receive_OOB[color=#9aff9a]:
   [ OOB( <channelname, SendType, ReceiveType>, m ) ]
  -->
   [ In_OOB( <channelname, SendType, ReceiveType>, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_InitDevice[color=#ffefd5]:
   [ Fr( ~MacAdd ), Fr( ~skI ) ]
  --[
  Unique( $D ), OnlyoneInit( ), InitD_IOCapability( 'DisplayOnly' ),
  AFMITMI( '1' ), InitDOOBOut( '1' ), InitDOOBIn( '1' )
  ]->
   [
   !Device( $D, ~MacAdd, 'DisplayOnly', <'1', '1'>, '1', ~skI, 'Initiator' )
   ]

  /* has exactly the trivial AC variant */

restriction OnlyoneInit:
  "∀ #i #j. ((OnlyoneInit( ) @ #i) ∧ (OnlyoneInit( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) Init_ResDevice[color=#ffefd5]:
   [ Fr( ~MacAdd ), Fr( ~skR ) ]
  --[
  Unique( $D ), OnlyoneRes( ), ResD_IOCapability( 'DisplayOnly' ),
  AFMITMR( '1' ), ResDOOBOut( '1' ), ResDOOBIn( '1' )
  ]->
   [
   !Device( $D, ~MacAdd, 'DisplayOnly', <'1', '1'>, '1', ~skR, 'Responder' )
   ]

  /* has exactly the trivial AC variant */

restriction OnlyoneRes:
  "∀ #i #j. ((OnlyoneRes( ) @ #i) ∧ (OnlyoneRes( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) InitDOutOOBinfo[color=#bbffff]:
   [
   !Device( InitD, MacAddI, IOCapabilityI, <'1', i>, MITMI, ~skI,
            'Initiator'
   ),
   Fr( ~ri )
   ]
  -->
   [
   Out_OOB( <'OOB', 'InitD', 'ResD'>,
            <MacAddI, ~ri, f4('g'^~skI, 'g'^~skI, ~ri, '0')>
   ),
   !State_InitD_SentOOBInfo( ~ri, f4('g'^~skI, 'g'^~skI, ~ri, '0') )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDOutOOBinfo[color=#fff68f]:
   [
   !Device( ResD, MacAddR, IOCapabilityR, <'1', i>, MITMR, ~skR, 'Responder'
   ),
   Fr( ~rr )
   ]
  -->
   [
   Out_OOB( <'OOB', 'ResD', 'InitD'>,
            <MacAddR, ~rr, f4('g'^~skR, 'g'^~skR, ~rr, '0')>
   ),
   !State_ResD_SentOOBInfo( ~rr, f4('g'^~skR, 'g'^~skR, ~rr, '0') )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitDInOOBinfo[color=#bbffff]:
   [
   !Device( InitD, MacAddI, IOCapabilityI, <i, '1'>, MITMI, ~skI,
            'Initiator'
   ),
   In_OOB( <'OOB', 'ResD', 'InitD'>, <MacAddR, rb, Cb> )
   ]
  --[ OnlyoneInitInOOB( InitD ) ]->
   [ !State_InitD_RevOOBInfo( MacAddR, rb, Cb ) ]

  /* has exactly the trivial AC variant */

restriction OnlyoneInitInOOB:
  "∀ x #i #j.
    ((OnlyoneInitInOOB( x ) @ #i) ∧ (OnlyoneInitInOOB( x ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

rule (modulo E) ResDInOOBinfo[color=#fff68f]:
   [
   !Device( ResD, MacAddR, IOCapabilityR, <i, '1'>, MITMR, ~skR, 'Responder'
   ),
   In_OOB( <'OOB', 'InitD', 'ResD'>, <MacAddI, ra, Ca> )
   ]
  --[ OnlyoneResInOOB( ResD ) ]->
   [ !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ]

  /* has exactly the trivial AC variant */

restriction OnlyoneResInOOB:
  "∀ x #i #j.
    ((OnlyoneResInOOB( x ) @ #i) ∧ (OnlyoneResInOOB( x ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) Init_User[color=#ffefd5]:
   [ ] --[ OnlyoneUser( ) ]-> [ !User( $User ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Advertising[color=#fff68f]:
   [
   !Device( ResD, MacAddR, IOCapabilityR, OOBCapabilityR, MITMR, ~skR,
            'Responder'
   )
   ]
  -->
   [ Out( <ResD, MacAddR> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Scan[color=#bbffff]:
   [
   In( <ResD, MacAddR> ),
   !Device( InitD, MacAddI, IOCapabilityI, OOBCapabilityI, MITMI, ~skI,
            'Initiator'
   )
   ]
  --[ OneInitOneResD( InitD, ResD ), Neq( InitD, ResD ) ]->
   [
   State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI, ResD, MacAddR )
   ]

  /* has exactly the trivial AC variant */

restriction OneInitOneResD:
  "∀ x y z #i #j.
    ((OneInitOneResD( x, y ) @ #i) ∧ (OneInitOneResD( x, z ) @ #j)) ⇒
    ((#i = #j) ∧ (y = z))"
  // safety formula

rule (modulo E) InitDRequest[color=#bbffff]:
   [
   State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI, ResD, MacAddR )
   ]
  --[ InitD_OOBFlag( '0' ) ]->
   [
   !Pairing( InitD, ResD ),
   Out( <MacAddI, MacAddR, InitD, 'Req', IOCapabilityI, '0', MITMI, '16'> ),
   InitDReqPairing( InitD, MacAddI, IOCapabilityI, '0', MITMI, ResD,
                    MacAddR, ~skI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDSResponse[color=#fff68f]:
   [
   In( <MacAddI, MacAddR, InitD, 'Req', IOCapabilityI, OOBflagI, MITMI, 
        KeySizeInit>
   ),
   !Device( ResD, MacAddR, IOCapabilityR, OOBCapabilityR, MITMR, ~skR,
            'Responder'
   )
   ]
  --[ AFResDOnlyOneThread( ), ResD_OOBFlag( '0' ) ]->
   [
   !Pairing( InitD, ResD ),
   ResDStartPairing( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                     IOCapabilityR, '0', MITMR, ~skR
   ),
   Out( <MacAddR, MacAddI, 'response', IOCapabilityR, '0', MITMR, '16'> ),
   !InitDKeySize( KeySizeInit )
   ]

  /* has exactly the trivial AC variant */

restriction ResDOnlyOneThread:
  "∀ #i #j.
    ((AFResDOnlyOneThread( ) @ #i) ∧ (AFResDOnlyOneThread( ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

rule (modulo E) InitDRequestWithOOBflagI1[color=#bbffff]:
   [
   State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI, ResD, MacAddR
   ),
   !State_InitD_RevOOBInfo( MacAddR, rb, Cb )
   ]
  --[ InitD_OOBFlag( '1' ), InitDOOB1( ) ]->
   [
   !Pairing( InitD, ResD ),
   Out( <MacAddI, MacAddR, InitD, 'Req', IOCapabilityI, '1', MITMI, '16'> ),
   InitDReqPairing( InitD, MacAddI, IOCapabilityI, '1', MITMI, ResD,
                    MacAddR, ~skI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDSResponseWithOOBflagR1[color=#fff68f]:
   [
   In( <MacAddI, MacAddR, InitD, 'Req', IOCapabilityI, OOBflagI, MITMI, 
        KeySizeInit>
   ),
   !Device( ResD, MacAddR, IOCapabilityR, OOBCapabilityR, MITMR, ~skR,
            'Responder'
   ),
   !State_ResD_RevOOBInfo( MacAddI, ra, Ca )
   ]
  --[ AFResDOnlyOneThread( ), ResD_OOBFlag( '1' ), ResDOOB1( ) ]->
   [
   !Pairing( InitD, ResD ),
   ResDStartPairing( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                     IOCapabilityR, '1', MITMR, ~skR
   ),
   Out( <MacAddR, MacAddI, 'response', IOCapabilityR, '1', MITMR, '16'> ),
   !InitDKeySize( KeySizeInit )
   ]

  /* has exactly the trivial AC variant */

restriction OOBCapToOOBFlagInitD:
  "∀ #i #j.
    ((ResDOOBOut( '1' ) @ #i) ∧ (InitDOOBIn( '1' ) @ #j)) ⇒
    (∃ #k. InitDOOB1( ) @ #k)"

restriction OOBCapToOOBFlagResD:
  "∀ #i #j.
    ((InitDOOBOut( '1' ) @ #i) ∧ (ResDOOBIn( '1' ) @ #j)) ⇒
    (∃ #k. ResDOOB1( ) @ #k)"

rule (modulo E) InitDStartPairing[color=#bbffff]:
   [
   In( <MacAddR, MacAddI, 'response', IOCapabilityR, OOBflagR, MITMR, 
        KeySizeRes>
   ),
   InitDReqPairing( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, ResD,
                    MacAddR, ~skI
   )
   ]
  -->
   [
   InitDStartPairing( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI
   ),
   !ResDKeySize( KeySizeRes )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitDSendDH[color=#bbffff]:
   [
   InitDStartPairing( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI
   )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, 'g'^~skI> ),
   InitDSentDH( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                IOCapabilityR, OOBflagR, MITMR, ~skI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDRecDHSendDH[color=#fff68f]:
   [
   ResDStartPairing( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                     IOCapabilityR, OOBflagR, MITMR, ~skR
   ),
   In( <MacAddI, MacAddR, DHpkI> )
   ]
  --[ Running_Res( MacAddR, MacAddI, <'DHKey', DHpkI^~skR> ) ]->
   [
   Out( <MacAddR, MacAddI, 'g'^~skR> ),
   ResDDHKey( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
              IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHpkI^~skR
   )
   ]

  /*
  rule (modulo AC) ResDRecDHSendDH[color=#fff68f]:
     [
     ResDStartPairing( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                       IOCapabilityR, OOBflagR, MITMR, ~skR
     ),
     In( <MacAddI, MacAddR, DHpkI> )
     ]
    --[ Running_Res( MacAddR, MacAddI, <'DHKey', z> ) ]->
     [
     Out( <MacAddR, MacAddI, 'g'^~skR> ),
     ResDDHKey( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, z
     )
     ]
    variants (modulo AC)
    1. ~skR  = ~skR.16
       DHpkI = DHpkI.17
       z     = DHpkI.17^~skR.16
    
    2. ~skR  = ~skR.27
       DHpkI = z.39^inv(~skR.27)
       z     = z.39
    
    3. ~skR  = ~skR.82
       DHpkI = x.161^x.162
       z     = x.161^(~skR.82*x.162)
    
    4. ~skR  = ~skR.83
       DHpkI = x.163^inv((~skR.83*x.164))
       z     = x.163^inv(x.164)
    
    5. ~skR  = ~skR.83
       DHpkI = x.163^(x.164*inv(~skR.83))
       z     = x.163^x.164
    
    6. ~skR  = ~skR.84
       DHpkI = x.164^(x.165*inv((~skR.84*x.166)))
       z     = x.164^(x.165*inv(x.166))
  */

rule (modulo E) InitDRevDH[color=#bbffff]:
   [
   InitDSentDH( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                IOCapabilityR, OOBflagR, MITMR, ~skI
   ),
   In( <MacAddR, MacAddI, DHpkR> )
   ]
  --[ Running_Init( MacAddI, MacAddR, <'DHKey', DHpkR^~skI> ) ]->
   [
   InitDDHKey( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
               IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHpkR^~skI
   )
   ]

  /*
  rule (modulo AC) InitDRevDH[color=#bbffff]:
     [
     InitDSentDH( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI
     ),
     In( <MacAddR, MacAddI, DHpkR> )
     ]
    --[ Running_Init( MacAddI, MacAddR, <'DHKey', z> ) ]->
     [
     InitDDHKey( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, z
     )
     ]
    variants (modulo AC)
    1. ~skI  = ~skI.14
       DHpkR = DHpkR.15
       z     = DHpkR.15^~skI.14
    
    2. ~skI  = ~skI.15
       DHpkR = z.26^inv(~skI.15)
       z     = z.26
    
    3. ~skI  = ~skI.16
       DHpkR = x.28^x.29
       z     = x.28^(~skI.16*x.29)
    
    4. ~skI  = ~skI.16
       DHpkR = x.29^inv((~skI.16*x.30))
       z     = x.29^inv(x.30)
    
    5. ~skI  = ~skI.16
       DHpkR = x.29^(x.30*inv(~skI.16))
       z     = x.29^x.30
    
    6. ~skI  = ~skI.17
       DHpkR = x.30^(x.31*inv((~skI.17*x.32)))
       z     = x.30^(x.31*inv(x.32))
  */

rule (modulo E) JW_ResDCommitment_NoMITMSet[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, IOCapabilityI, '0', '0', MacAddR,
              IOCapabilityR, '0', '0', ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, IOCapabilityI, '0', '0',
                                 MacAddR, IOCapabilityR, '0', '0', ~skR, DHpkI, DHKeyR, '0', '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoMITMSet[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, IOCapabilityI, '0', '0', MacAddR,
               IOCapabilityR, '0', '0', ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, IOCapabilityI, '0', '0',
                             MacAddR, IOCapabilityR, '0', '0', ~skI, DHpkR, DHKeyI, '0', '0', ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

restriction NoMITMSetJW:
  "∀ #i #j.
    ((AFMITMI( '0' ) @ #i) ∧ (AFMITMR( '0' ) @ #j)) ⇒
    (∃ #m #n. (InitDJW( ) @ #m) ∧ (ResDJW( ) @ #n))"

rule (modulo E) JW_ResDCommitment_DisplayOnly_DisplayOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
              'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayOnly', '0', MITMI,
                                 MacAddR, 'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_DisplayYesNo_DisplayOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
              'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayYesNo', '0', MITMI,
                                 MacAddR, 'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_NoInputNoOutput_DisplayOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
              'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'NoInputNoOutput', '0',
                                 MITMI, MacAddR, 'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0',
                                 ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_DisplayOnly_DisplayYesNo[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
              'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayOnly', '0', MITMI,
                                 MacAddR, 'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_NoInputNoOutput_DisplayYesNo[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
              'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'NoInputNoOutput', '0',
                                 MITMI, MacAddR, 'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_NoInputNoOutput_KeyboardOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
              'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'NoInputNoOutput', '0',
                                 MITMI, MacAddR, 'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_DisplayOnly_NoInputNoOutput[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
              'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayOnly', '0', MITMI,
                                 MacAddR, 'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0',
                                 ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_DisplayYesNo_NoInputNoOutput[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
              'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayYesNo', '0', MITMI,
                                 MacAddR, 'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0',
                                 ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_KeyboardOnly_NoInputNoOutput[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
              'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'KeyboardOnly', '0', MITMI,
                                 MacAddR, 'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0',
                                 ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_NoInputNoOutput_NoInputNoOutput[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
              'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'NoInputNoOutput', '0',
                                 MITMI, MacAddR, 'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_KeyboardDisplay_NoInputNoOutput[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
              'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'KeyboardDisplay', '0',
                                 MITMI, MacAddR, 'NoInputNoOutput', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDCommitment_NoInputNoOutput_KeyboardDisplay[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
              'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  --[ ResDJW( ) ]->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   JW_State_Res_Sent_Commitment( ResD, MacAddI, 'NoInputNoOutput', '0',
                                 MITMI, MacAddR, 'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_DisplayOnly_DisplayOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
               'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayOnly', '0', MITMI,
                             MacAddR, 'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_DisplayYesNo_DisplayOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
               'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayYesNo', '0', MITMI,
                             MacAddR, 'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoInputNoOutput_DisplayOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
               'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI,
                             MacAddR, 'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_DisplayOnly_DisplayYesNo[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
               'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayOnly', '0', MITMI,
                             MacAddR, 'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoInputNoOutput_DisplayYesNo[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
               'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI,
                             MacAddR, 'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoInputNoOutput_KeyboardOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
               'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI,
                             MacAddR, 'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_DisplayOnly_NoInputNoOutput[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
               'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayOnly', '0', MITMI,
                             MacAddR, 'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_DisplayYesNo_NoInputNoOutput[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
               'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayYesNo', '0', MITMI,
                             MacAddR, 'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_KeyboardOnly_NoInputNoOutput[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
               'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'KeyboardOnly', '0', MITMI,
                             MacAddR, 'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoInputNoOutput_NoInputNoOutput[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
               'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI,
                             MacAddR, 'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_KeyboardDisplay_NoInputNoOutput[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
               'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI,
                             MacAddR, 'NoInputNoOutput', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDSendNonce_NoInputNoOutput_KeyboardDisplay[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI, MacAddR,
               'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  --[ InitDJW( ) ]->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   JW_State_Init_Sent_Nonce( InitD, MacAddI, 'NoInputNoOutput', '0', MITMI,
                             MacAddR, 'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDSendNonce[color=#fff68f]:
   [
   JW_State_Res_Sent_Commitment( ResD, MacAddI, IOCapabilityI, OOBflagI,
                                 MITMI, MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra,
                                 rb, ~Nb
   ),
   In( <MacAddI, MacAddR, Na> )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, ~Nb> ),
   JW_State_Res_Checked( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                         ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDCheck[color=#bbffff]:
   [
   JW_State_Init_Sent_Nonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                             ~Na, Cb
   ),
   In( <MacAddR, MacAddI, Nb> )
   ]
  --[ Eq( Cb, f4(DHpkR, 'g'^~skI, Nb, '0') ) ]->
   [
   JW_State_Init_Checked( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                          ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_ResDOK[color=#fff68f]:
   [
   JW_State_Res_Checked( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                         ~Nb
   )
   ]
  -->
   [
   State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) JW_InitDOk[color=#bbffff]:
   [
   JW_State_Init_Checked( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                          ~Na, Nb
   )
   ]
  -->
   [
   State_Init_OK( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDCommitment_DisplayYesNo_DisplayYesNo[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
              'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   NC_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayYesNo', '0', MITMI,
                                 MacAddR, 'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDCommitment_KeyboardDisplay_DisplayYesNo[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
              'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   NC_State_Res_Sent_Commitment( ResD, MacAddI, 'KeyboardDisplay', '0',
                                 MITMI, MacAddR, 'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDCommitment_DisplayYesNo_KeyboardDisplay[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
              'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   NC_State_Res_Sent_Commitment( ResD, MacAddI, 'DisplayYesNo', '0', MITMI,
                                 MacAddR, 'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR, '0', '0',
                                 ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDCommitment_KeyboardDisplay_KeyboardDisplay[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
              'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~Nb )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, '0')> ),
   NC_State_Res_Sent_Commitment( ResD, MacAddI, 'KeyboardDisplay', '0',
                                 MITMI, MacAddR, 'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR, '0',
                                 '0', ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitDSendNonce_DisplayYesNo_DisplayYesNo[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
               'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   NC_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayYesNo', '0', MITMI,
                             MacAddR, 'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitDSendNonce_KeyboardDisplay_DisplayYesNo[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
               'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   NC_State_Init_Sent_Nonce( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI,
                             MacAddR, 'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0', ~Na,
                             Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitDSendNonce_DisplayYesNo_KeyboardDisplay[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
               'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   NC_State_Init_Sent_Nonce( InitD, MacAddI, 'DisplayYesNo', '0', MITMI,
                             MacAddR, 'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitDSendNonce_KeyboardDisplay_KeyboardDisplay[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
               'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~Na ), In( Cb )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   NC_State_Init_Sent_Nonce( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI,
                             MacAddR, 'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI, '0', '0',
                             ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDSendNonceDisplay[color=#fff68f]:
   [
   NC_State_Res_Sent_Commitment( ResD, MacAddI, IOCapabilityI, OOBflagI,
                                 MITMI, MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra,
                                 rb, ~Nb
   ),
   In( <MacAddI, MacAddR, Na> )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, ~Nb> ),
   Out_A( <'DisplayConfirm', 'Device', 'User'>, ResD, $User,
          g2(DHpkI, 'g'^~skR, Na, ~Nb)
   ),
   NC_State_Res_Displayed( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                           ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitCheckDisplay[color=#bbffff]:
   [
   NC_State_Init_Sent_Nonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                             ~Na, Cb
   ),
   In( <MacAddR, MacAddI, Nb> )
   ]
  --[ Eq( Cb, f4(DHpkR, 'g'^~skI, Nb, '0') ) ]->
   [
   Out_A( <'DisplayConfirm', 'Device', 'User'>, InitD, $User,
          g2('g'^~skI, DHpkR, ~Na, Nb)
   ),
   NC_State_Init_Displayed( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                            ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_ResDOK[color=#fff68f]:
   [
   NC_State_Res_Displayed( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                           ~Nb
   ),
   In_A( <'Confirm', 'User', 'Device'>, $User, ResD, 'T' )
   ]
  --[ ResDNC( ) ]->
   [
   State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) NC_InitDOk[color=#bbffff]:
   [
   NC_State_Init_Displayed( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                            ~Na, Nb
   ),
   In_A( <'Confirm', 'User', 'Device'>, $User, InitD, 'T' )
   ]
  --[ InitDNC( ) ]->
   [
   State_Init_OK( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDDisplay_DisplayOnly_KeyboardOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
               'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, InitD, $User, ~r ),
   PE_InitDDisplayed( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
                      'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDDisplay_DisplayYesNo_KeyboardOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
               'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, InitD, $User, ~r ),
   PE_InitDDisplayed( InitD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
                      'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDDisplay_KeyboardDisplay_KeyboardOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
               'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, InitD, $User, ~r ),
   PE_InitDDisplayed( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI,
                      MacAddR, 'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDDisplay_DisplayOnly_KeyboardDisplay[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
               'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, InitD, $User, ~r ),
   PE_InitDDisplayed( InitD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
                      'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDAskforInput_KeyboardOnly_DisplayOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
               'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, InitD, $User, 'Input' ),
   PE_InitDWaitInput( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                      'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDAskforInput_KeyboardDisplay_DisplayOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
               'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, InitD, $User, 'Input' ),
   PE_InitDWaitInput( InitD, MacAddI, 'KeyboardDisplay', '0', MITMI,
                      MacAddR, 'DisplayOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDAskforInput_KeyboardOnly_DisplayYesNo[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
               'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, InitD, $User, 'Input' ),
   PE_InitDWaitInput( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                      'DisplayYesNo', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDAskforInput_KeyboardOnly_KeyboardOnly[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
               'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, InitD, $User, 'Input' ),
   PE_InitDWaitInput( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                      'KeyboardOnly', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDAskforInput_KeyboardOnly_KeyboardDisplay[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
               'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, InitD, $User, 'Input' ),
   PE_InitDWaitInput( InitD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                      'KeyboardDisplay', '0', MITMR, ~skI, DHpkR, DHKeyI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDDisplay_KeyboardOnly_DisplayOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
              'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, ResD, $User, ~r ),
   PE_ResDDisplayed( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                     'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDDisplay_KeyboardDisplay_DisplayOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
              'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, ResD, $User, ~r ),
   PE_ResDDisplayed( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
                     'DisplayOnly', '0', MITMR, ~skR, DHpkI, DHKeyR, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDDisplay_KeyboardOnly_DisplayYesNo[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
              'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, ResD, $User, ~r ),
   PE_ResDDisplayed( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                     'DisplayYesNo', '0', MITMR, ~skR, DHpkI, DHKeyR, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDDisplay_KeyboardOnly_KeyboardDisplay[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
              'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   ),
   Fr( ~r )
   ]
  -->
   [
   Out_A( <'Display', 'Device', 'User'>, ResD, $User, ~r ),
   PE_ResDDisplayed( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                     'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDAskforInput_DisplayOnly_KeyboardOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
              'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input' ),
   PE_ResDWaitInput( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
                     'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDAskforInput_DisplayYesNo_KeyboardOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
              'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input' ),
   PE_ResDWaitInput( ResD, MacAddI, 'DisplayYesNo', '0', MITMI, MacAddR,
                     'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDAskforInput_KeyboardOnly_KeyboardOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
              'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input' ),
   PE_ResDWaitInput( ResD, MacAddI, 'KeyboardOnly', '0', MITMI, MacAddR,
                     'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDAskforInput_KeyboardDisplay_KeyboardOnly[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
              'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input' ),
   PE_ResDWaitInput( ResD, MacAddI, 'KeyboardDisplay', '0', MITMI, MacAddR,
                     'KeyboardOnly', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDAskforInput_DisplayOnly_KeyboardDisplay[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
              'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]
  -->
   [
   Out_A( <'AskforInput', 'Device', 'User'>, ResD, $User, 'Input' ),
   PE_ResDWaitInput( ResD, MacAddI, 'DisplayOnly', '0', MITMI, MacAddR,
                     'KeyboardDisplay', '0', MITMR, ~skR, DHpkI, DHKeyR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDUserInputInjectSecret[color=#fff68f]:
   [
   PE_ResDWaitInput( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                     IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR
   ),
   In_A( <'Input', 'User', 'Device'>, $User, ResD, r )
   ]
  -->
   [
   PE_ResDInjectSecret( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                        MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, r, r
   ),
   Out( <MacAddR, MacAddI, 'KeypressNotification'> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDUserInputInjectSecret[color=#bbffff]:
   [
   PE_InitDWaitInput( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI
   ),
   In_A( <'Input', 'User', 'Device'>, $User, InitD, r )
   ]
  -->
   [
   PE_InitDInjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, r, r
   ),
   Out( <MacAddI, MacAddR, 'KeypressNotification'> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDUserOKInjectSecret[color=#bbffff]:
   [
   PE_InitDDisplayed( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ~r
   ),
   In( <MacAddR, MacAddI, 'KeypressNotification'> )
   ]
  -->
   [
   PE_InitDInjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ~r, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDUserOKInjectSecret[color=#fff68f]:
   [
   PE_ResDDisplayed( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                     IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ~r
   ),
   In( <MacAddI, MacAddR, 'KeypressNotification'> )
   ]
  -->
   [
   PE_ResDInjectSecret( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                        MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ~r, ~r
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDCommitment[color=#bbffff]:
   [
   PE_InitDInjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb
   ),
   Fr( ~Na )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, f4('g'^~skI, DHpkR, ~Na, ra)> ),
   PE_InitDSentCommitment( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDCommitment[color=#fff68f]:
   [
   PE_ResDInjectSecret( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                        MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb
   ),
   In( <MacAddI, MacAddR, Ca> ), Fr( ~Nb )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, f4('g'^~skR, DHpkI, ~Nb, rb)> ),
   PE_ResDSentCommitment( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb,
                          ~Nb, Ca
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDSendNonce[color=#bbffff]:
   [
   PE_InitDSentCommitment( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na
   ),
   In( <MacAddR, MacAddI, Cb> )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   PE_InitDSentNonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                      ~Na, Cb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_ResDCheckSendNonceOK[color=#fff68f]:
   [
   PE_ResDSentCommitment( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb,
                          ~Nb, Ca
   ),
   In( <MacAddI, MacAddR, Na> )
   ]
  --[ Eq( Ca, f4(DHpkI, 'g'^~skR, Na, rb) ), ResDPE( ) ]->
   [
   Out( <MacAddR, MacAddI, ~Nb> ),
   State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) PE_InitDCheckOK[color=#bbffff]:
   [
   PE_InitDSentNonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                      MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                      ~Na, Cb
   ),
   In( <MacAddR, MacAddI, Nb> )
   ]
  --[ Eq( Cb, f4(DHpkR, 'g'^~skI, Nb, ra) ), InitDPE( ) ]->
   [
   State_Init_OK( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) User_NC[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'DisplayConfirm', 'Device', 'User'>, D1, User, m ),
   In_A( <'DisplayConfirm', 'Device', 'User'>, D2, User, m )
   ]
  --[ AFOneInteraction( ) ]->
   [
   Out_A( <'Confirm', 'User', 'Device'>, User, D1, 'T' ),
   Out_A( <'Confirm', 'User', 'Device'>, User, D2, 'T' )
   ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

rule (modulo E) User_PE_0[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'AskforInput', 'Device', 'User'>, D1, User, 'Input' ),
   In_A( <'AskforInput', 'Device', 'User'>, D2, User, 'Input' ),
   Fr( ~passkey )
   ]
  --[ AFOneInteraction( ) ]->
   [
   Out_A( <'Input', 'User', 'Device'>, User, D1, ~passkey ),
   Out_A( <'Input', 'User', 'Device'>, User, D2, ~passkey )
   ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

rule (modulo E) User_PE_1[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'Display', 'Device', 'User'>, D1, User, m ),
   In_A( <'AskforInput', 'Device', 'User'>, D2, User, 'Input' )
   ]
  --[ AFOneInteraction( ) ]->
   [ Out_A( <'Input', 'User', 'Device'>, User, D2, m ) ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

rule (modulo E) User_PE_2[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'AskforInput', 'Device', 'User'>, D1, User, 'Input' ),
   In_A( <'Display', 'Device', 'User'>, D2, User, m )
   ]
  --[ AFOneInteraction( ) ]->
   [ Out_A( <'Input', 'User', 'Device'>, User, D1, m ) ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

rule (modulo E) User_UnderAttack_1[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'AskforInput', 'Device', 'User'>, D1, User, 'Input' ),
   In_A( <'DisplayConfirm', 'Device', 'User'>, D2, User, m )
   ]
  --[ AFOneInteraction( ) ]->
   [
   Out_A( <'Input', 'User', 'Device'>, User, D1, m ),
   Out_A( <'Confirm', 'User', 'Device'>, User, D2, 'T' )
   ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

rule (modulo E) User_UnderAttack_2[color=#6495ed]:
   [
   !User( User ), !Pairing( D1, D2 ),
   In_A( <'DisplayConfirm', 'Device', 'User'>, D1, User, m ),
   In_A( <'AskforInput', 'Device', 'User'>, D2, User, 'Input' )
   ]
  --[ AFOneInteraction( ) ]->
   [
   Out_A( <'Confirm', 'User', 'Device'>, User, D1, 'T' ),
   Out_A( <'Input', 'User', 'Device'>, User, D2, m )
   ]

  // loop breakers: [2,3]
  /* has exactly the trivial AC variant */

restriction OneInteraction:
  "∀ #i #j.
    ((AFOneInteraction( ) @ #i) ∧ (AFOneInteraction( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) OOB_InitDInjectSecretsWithOOBflagR0I1[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
               IOCapabilityR, '0', MITMR, ~skI, DHpkR, DHKeyI
   ),
   !State_InitD_RevOOBInfo( MacAddR, rb, Cb )
   ]
  --[ Eq( Cb, f4(DHpkR, DHpkR, rb, '0') ) ]->
   [
   State_InitD_InjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, '0', MITMR, ~skI, DHpkR, DHKeyI, '0', rb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_InitDInjectSecretsWithOOBflagR1I0[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
               IOCapabilityR, '1', MITMR, ~skI, DHpkR, DHKeyI
   ),
   !State_InitD_SentOOBInfo( ra, Ca )
   ]
  -->
   [
   State_InitD_InjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, '1', MITMR, ~skI, DHpkR, DHKeyI, ra, '0'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_InitDInjectSecretsWithOOBflagR1I1[color=#bbffff]:
   [
   InitDDHKey( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
               IOCapabilityR, '1', MITMR, ~skI, DHpkR, DHKeyI
   ),
   !State_InitD_RevOOBInfo( MacAddR, rb, Cb ),
   !State_InitD_SentOOBInfo( ra, Ca )
   ]
  --[ Eq( Cb, f4(DHpkR, DHpkR, rb, '0') ) ]->
   [
   State_InitD_InjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, '1', MITMR, ~skI, DHpkR, DHKeyI, ra, rb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_ResDInjectSecretsWithOOBflagI0R1[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, IOCapabilityI, '0', MITMI, MacAddR,
              IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR
   ),
   !State_ResD_RevOOBInfo( MacAddI, ra, Ca )
   ]
  --[ Eq( Ca, f4(DHpkI, DHpkI, ra, '0') ) ]->
   [
   State_ResD_InjectSecret( ResD, MacAddI, IOCapabilityI, '0', MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, '0'
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_ResDInjectSecretsWithOOBflagI1R0[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, IOCapabilityI, '1', MITMI, MacAddR,
              IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR
   ),
   !State_ResD_SentOOBInfo( rb, Cb )
   ]
  -->
   [
   State_ResD_InjectSecret( ResD, MacAddI, IOCapabilityI, '1', MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, '0', rb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_ResDInjectSecretsWithOOBflagI1R1[color=#fff68f]:
   [
   ResDDHKey( ResD, MacAddI, IOCapabilityI, '1', MITMI, MacAddR,
              IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR
   ),
   !State_ResD_RevOOBInfo( MacAddI, ra, Ca ),
   !State_ResD_SentOOBInfo( rb, Cb )
   ]
  --[ Eq( Ca, f4(DHpkI, DHpkI, ra, '0') ) ]->
   [
   State_ResD_InjectSecret( ResD, MacAddI, IOCapabilityI, '1', MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_InitDSendNonce[color=#bbffff]:
   [
   State_InitD_InjectSecret( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                             MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb
   ),
   Fr( ~Na )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, ~Na> ),
   OOB_InitDSentNonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                       MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_ResDOK[color=#fff68f]:
   [
   In( <MacAddI, MacAddR, Na> ),
   State_ResD_InjectSecret( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb
   ),
   Fr( ~Nb )
   ]
  --[ ResDOOB( ) ]->
   [
   Out( <MacAddR, MacAddI, ~Nb> ),
   State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OOB_InitDOK[color=#bbffff]:
   [
   In( <MacAddR, MacAddI, Nb> ),
   OOB_InitDSentNonce( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                       MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na
   )
   ]
  --[ InitDOOB( ) ]->
   [
   State_Init_OK( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitDSendEa[color=#bbffff]:
   [
   !ResDKeySize( KeySizeRes ),
   State_Init_OK( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                  IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb
   )
   ]
  --[
  Running_Init( MacAddI, MacAddR,
                <'LTK', resize(snd(f5(DHKeyI, ~Na, Nb, MacAddI, MacAddR)), KeySizeRes)>
  ),
  SecLTK( resize(snd(f5(DHKeyI, ~Na, Nb, MacAddI, MacAddR)), KeySizeRes) )
  ]->
   [
   Out( <MacAddI, MacAddR, 
         f6(fst(f5(DHKeyI, ~Na, Nb, MacAddI, MacAddR)), ~Na, Nb, rb,
            IOCapabilityI, MacAddI, MacAddR)
        >
   ),
   InitDSentEa( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                fst(f5(DHKeyI, ~Na, Nb, MacAddI, MacAddR)),
                resize(snd(f5(DHKeyI, ~Na, Nb, MacAddI, MacAddR)), KeySizeRes)
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDSendEb[color=#fff68f]:
   [
   !InitDKeySize( KeySizeInit ),
   State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                 IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
   ),
   In( <MacAddI, MacAddR, Ea> )
   ]
  --[
  Running_Res( MacAddR, MacAddI,
               <'LTK', resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)>
  ),
  SecLTK( resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)
  ),
  Eq( Ea,
      f6(fst(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), Na, ~Nb, rb,
         IOCapabilityI, MacAddI, MacAddR)
  ),
  Commit_Res( MacAddR, MacAddI,
              <'LTK', resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)>
  ),
  Commit_Res( MacAddR, MacAddI, <'DHKey', DHKeyR> ), FinishedRes( ),
  MP( MacAddI, MacAddR ),
  LTK( MacAddR, MacAddI,
       resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)
  ),
  FSecAuthLTK( MacAddR, MacAddI,
               resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)
  )
  ]->
   [
   Out( <MacAddR, MacAddI, 
         f6(fst(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), ~Nb, Na, ra,
            IOCapabilityR, MacAddR, MacAddI)
        >
   ),
   State_ResDAuthSta2_End( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                           ~Nb, resize(snd(f5(DHKeyR, Na, ~Nb, MacAddI, MacAddR)), KeySizeInit)
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitDCheck[color=#bbffff]:
   [
   InitDSentEa( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI, MacAddR,
                IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                MacKeyI, LTKI
   ),
   In( <MacAddR, MacAddI, Eb> )
   ]
  --[
  Eq( Eb, f6(MacKeyI, Nb, ~Na, ra, IOCapabilityR, MacAddR, MacAddI) ),
  Commit_Init( MacAddI, MacAddR, <'LTK', LTKI> ),
  Commit_Init( MacAddI, MacAddR, <'DHKey', DHKeyI> ), FinishedInit( ),
  MP( MacAddI, MacAddR ), LTK( MacAddI, MacAddR, LTKI ),
  FSecAuthLTK( MacAddI, MacAddR, LTKI )
  ]->
   [
   State_InitDAuthSta2_End( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                            ~Na, Nb, MacKeyI, LTKI
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDDistribution[color=#fff68f]:
   [
   State_ResDAuthSta2_End( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                           MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                           ~Nb, LTKR
   ),
   Fr( ~IRKR ), Fr( ~BD_ADDRR ), Fr( ~CSRKR )
   ]
  -->
   [
   Out( <MacAddR, MacAddI, senc(<~IRKR, ~BD_ADDRR, ~CSRKR>, LTKR)> ),
   State_ResDDistributed( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                          ~Nb, LTKR, ~IRKR, ~BD_ADDRR, ~CSRKR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitDDistribution[color=#bbffff]:
   [
   State_InitDAuthSta2_End( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                            MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                            ~Na, Nb, MacKeyI, LTKI
   ),
   In( <MacAddR, MacAddI, senc(<IRKR, BD_ADDRR, CSRKR>, LTKI)> ),
   Fr( ~IRKI ), Fr( ~BD_ADDRI ), Fr( ~CSRKI )
   ]
  -->
   [
   Out( <MacAddI, MacAddR, senc(<~IRKI, ~BD_ADDRI, ~CSRKI>, LTKI)> ),
   State_InitDDistributedBoth( InitD, MacAddI, IOCapabilityI, OOBflagI,
                               MITMI, MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra,
                               rb, ~Na, Nb, MacKeyI, LTKI, ~IRKI, ~BD_ADDRI, ~CSRKI, IRKR, BD_ADDRR,
                               CSRKR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ResDRecDisI[color=#fff68f]:
   [
   State_ResDDistributed( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                          MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                          ~Nb, LTKR, ~IRKR, ~BD_ADDRR, ~CSRKR
   ),
   In( <MacAddI, MacAddR, senc(<IRKI, BD_ADDRI, CSRKI>, LTKR)> )
   ]
  --[ Sec( IRKI ) ]->
   [
   State_ResDDistributedBoth( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                              MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na,
                              ~Nb, LTKR, IRKI, BD_ADDRI, CSRKI, ~IRKR, ~BD_ADDRR, ~CSRKR
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) oracle[color=#ffff00]:
   [ In( senc(m, resize(key, '7')) ) ] --> [ Out( resize(key, '7') ) ]

  /* has exactly the trivial AC variant */

restriction OnlyoneUser:
  "∀ #i #j. ((OnlyoneUser( ) @ #i) ∧ (OnlyoneUser( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction Equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction Inequality:
  "∀ x #i. (Neq( x, x ) @ #i) ⇒ (⊥)"
  // safety formula

restriction unique:
  "∀ x #i #j. ((Unique( x ) @ #i) ∧ (Unique( x ) @ #j)) ⇒ (#i = #j)"
  // safety formula

lemma Executability:
  exists-trace
  "(((((((((((((((((((((((((((((((((((((((((((∃ #i #j.
                                               (FinishedInit( ) @ #i) ∧ (FinishedRes( ) @ #j)) ∧
                                             (∀ #m #n.
                                               ((InitD_OOBFlag( '1' ) @ #m) ∧ (ResD_OOBFlag( '0' ) @ #n)) ⇒
                                               (∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)))) ∧
                                            (∀ #m #n.
                                              ((InitD_OOBFlag( '0' ) @ #m) ∧ (ResD_OOBFlag( '1' ) @ #n)) ⇒
                                              (∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)))) ∧
                                           (∀ #m #n.
                                             ((InitD_OOBFlag( '1' ) @ #m) ∧ (ResD_OOBFlag( '1' ) @ #n)) ⇒
                                             (∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)))) ∧
                                          (∀ #m #n #s #t.
                                            ((((InitD_OOBFlag( '0' ) @ #s) ∧ (ResD_OOBFlag( '0' ) @ #t)) ∧
                                              (AFMITMI( '0' ) @ #m)) ∧
                                             (AFMITMR( '0' ) @ #n)) ⇒
                                            (∃ #p #q. (InitDJW( ) @ #p) ∧ (ResDJW( ) @ #q)))) ∧
                                         (∀ #m #n #r #s.
                                           ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                                (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                               (InitD_OOBFlag( '0' ) @ #r)) ∧
                                              (ResD_OOBFlag( '0' ) @ #s)) ∧
                                             (AFMITMI( '1' ) @ #m)) ∧
                                            (AFMITMR( '0' ) @ #n)) ⇒
                                           (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                        (∀ #m #n #r #s.
                                          ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                               (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                              (InitD_OOBFlag( '0' ) @ #r)) ∧
                                             (ResD_OOBFlag( '0' ) @ #s)) ∧
                                            (AFMITMI( '0' ) @ #m)) ∧
                                           (AFMITMR( '1' ) @ #n)) ⇒
                                          (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                       (∀ #m #n #r #s.
                                         ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                              (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                             (InitD_OOBFlag( '0' ) @ #r)) ∧
                                            (ResD_OOBFlag( '0' ) @ #s)) ∧
                                           (AFMITMI( '1' ) @ #m)) ∧
                                          (AFMITMR( '1' ) @ #n)) ⇒
                                         (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                      (∀ #m #n #r #s.
                                        ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                             (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                            (InitD_OOBFlag( '0' ) @ #r)) ∧
                                           (ResD_OOBFlag( '0' ) @ #s)) ∧
                                          (AFMITMI( '1' ) @ #m)) ∧
                                         (AFMITMR( '0' ) @ #n)) ⇒
                                        (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                     (∀ #m #n #r #s.
                                       ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                            (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                           (InitD_OOBFlag( '0' ) @ #r)) ∧
                                          (ResD_OOBFlag( '0' ) @ #s)) ∧
                                         (AFMITMI( '0' ) @ #m)) ∧
                                        (AFMITMR( '1' ) @ #n)) ⇒
                                       (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                    (∀ #m #n #r #s.
                                      ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                           (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                                          (InitD_OOBFlag( '0' ) @ #r)) ∧
                                         (ResD_OOBFlag( '0' ) @ #s)) ∧
                                        (AFMITMI( '1' ) @ #m)) ∧
                                       (AFMITMR( '1' ) @ #n)) ⇒
                                      (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                   (∀ #m #n #r #s.
                                     ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                          (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                         (InitD_OOBFlag( '0' ) @ #r)) ∧
                                        (ResD_OOBFlag( '0' ) @ #s)) ∧
                                       (AFMITMI( '1' ) @ #m)) ∧
                                      (AFMITMR( '0' ) @ #n)) ⇒
                                     (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                  (∀ #m #n #r #s.
                                    ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                         (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                        (InitD_OOBFlag( '0' ) @ #r)) ∧
                                       (ResD_OOBFlag( '0' ) @ #s)) ∧
                                      (AFMITMI( '0' ) @ #m)) ∧
                                     (AFMITMR( '1' ) @ #n)) ⇒
                                    (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                 (∀ #m #n #r #s.
                                   ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                        (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                       (InitD_OOBFlag( '0' ) @ #r)) ∧
                                      (ResD_OOBFlag( '0' ) @ #s)) ∧
                                     (AFMITMI( '1' ) @ #m)) ∧
                                    (AFMITMR( '1' ) @ #n)) ⇒
                                   (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                                (∀ #m #n #r #s.
                                  ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                       (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                      (InitD_OOBFlag( '0' ) @ #r)) ∧
                                     (ResD_OOBFlag( '0' ) @ #s)) ∧
                                    (AFMITMI( '1' ) @ #m)) ∧
                                   (AFMITMR( '0' ) @ #n)) ⇒
                                  (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                               (∀ #m #n #r #s.
                                 ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                      (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                     (InitD_OOBFlag( '0' ) @ #r)) ∧
                                    (ResD_OOBFlag( '0' ) @ #s)) ∧
                                   (AFMITMI( '0' ) @ #m)) ∧
                                  (AFMITMR( '1' ) @ #n)) ⇒
                                 (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                              (∀ #m #n #r #s.
                                ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                                     (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                                    (InitD_OOBFlag( '0' ) @ #r)) ∧
                                   (ResD_OOBFlag( '0' ) @ #s)) ∧
                                  (AFMITMI( '1' ) @ #m)) ∧
                                 (AFMITMR( '1' ) @ #n)) ⇒
                                (∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)))) ∧
                             (∀ #m #n #r #s.
                               ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                                    (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                                   (InitD_OOBFlag( '0' ) @ #r)) ∧
                                  (ResD_OOBFlag( '0' ) @ #s)) ∧
                                 (AFMITMI( '1' ) @ #m)) ∧
                                (AFMITMR( '0' ) @ #n)) ⇒
                               (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                            (∀ #m #n #r #s.
                              ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                                   (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                                  (InitD_OOBFlag( '0' ) @ #r)) ∧
                                 (ResD_OOBFlag( '0' ) @ #s)) ∧
                                (AFMITMI( '0' ) @ #m)) ∧
                               (AFMITMR( '1' ) @ #n)) ⇒
                              (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                           (∀ #m #n #r #s.
                             ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                                  (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                                 (InitD_OOBFlag( '0' ) @ #r)) ∧
                                (ResD_OOBFlag( '0' ) @ #s)) ∧
                               (AFMITMI( '1' ) @ #m)) ∧
                              (AFMITMR( '1' ) @ #n)) ⇒
                             (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                          (∀ #m #n #r #s.
                            ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                 (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                                (InitD_OOBFlag( '0' ) @ #r)) ∧
                               (ResD_OOBFlag( '0' ) @ #s)) ∧
                              (AFMITMI( '1' ) @ #m)) ∧
                             (AFMITMR( '0' ) @ #n)) ⇒
                            (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                         (∀ #m #n #r #s.
                           ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                                (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                               (InitD_OOBFlag( '0' ) @ #r)) ∧
                              (ResD_OOBFlag( '0' ) @ #s)) ∧
                             (AFMITMI( '0' ) @ #m)) ∧
                            (AFMITMR( '1' ) @ #n)) ⇒
                           (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                        (∀ #m #n #r #s.
                          ((((((InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
                               (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                              (InitD_OOBFlag( '0' ) @ #r)) ∧
                             (ResD_OOBFlag( '0' ) @ #s)) ∧
                            (AFMITMI( '1' ) @ #m)) ∧
                           (AFMITMR( '1' ) @ #n)) ⇒
                          (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                       (∀ #m #n #r #s.
                         ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                              (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                             (InitD_OOBFlag( '0' ) @ #r)) ∧
                            (ResD_OOBFlag( '0' ) @ #s)) ∧
                           (AFMITMI( '1' ) @ #m)) ∧
                          (AFMITMR( '0' ) @ #n)) ⇒
                         (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                      (∀ #m #n #r #s.
                        ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                             (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                            (InitD_OOBFlag( '0' ) @ #r)) ∧
                           (ResD_OOBFlag( '0' ) @ #s)) ∧
                          (AFMITMI( '0' ) @ #m)) ∧
                         (AFMITMR( '1' ) @ #n)) ⇒
                        (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                     (∀ #m #n #r #s.
                       ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                            (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
                           (InitD_OOBFlag( '0' ) @ #r)) ∧
                          (ResD_OOBFlag( '0' ) @ #s)) ∧
                         (AFMITMI( '1' ) @ #m)) ∧
                        (AFMITMR( '1' ) @ #n)) ⇒
                       (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                    (∀ #m #n #r #s.
                      ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                           (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                          (InitD_OOBFlag( '0' ) @ #r)) ∧
                         (ResD_OOBFlag( '0' ) @ #s)) ∧
                        (AFMITMI( '1' ) @ #m)) ∧
                       (AFMITMR( '0' ) @ #n)) ⇒
                      (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                   (∀ #m #n #r #s.
                     ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                          (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                         (InitD_OOBFlag( '0' ) @ #r)) ∧
                        (ResD_OOBFlag( '0' ) @ #s)) ∧
                       (AFMITMI( '0' ) @ #m)) ∧
                      (AFMITMR( '1' ) @ #n)) ⇒
                     (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                  (∀ #m #n #r #s.
                    ((((((InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
                         (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
                        (InitD_OOBFlag( '0' ) @ #r)) ∧
                       (ResD_OOBFlag( '0' ) @ #s)) ∧
                      (AFMITMI( '1' ) @ #m)) ∧
                     (AFMITMR( '1' ) @ #n)) ⇒
                    (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                 (∀ #m #n #r #s.
                   ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                        (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                       (InitD_OOBFlag( '0' ) @ #r)) ∧
                      (ResD_OOBFlag( '0' ) @ #s)) ∧
                     (AFMITMI( '1' ) @ #m)) ∧
                    (AFMITMR( '0' ) @ #n)) ⇒
                   (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
                (∀ #m #n #r #s.
                  ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                       (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                      (InitD_OOBFlag( '0' ) @ #r)) ∧
                     (ResD_OOBFlag( '0' ) @ #s)) ∧
                    (AFMITMI( '0' ) @ #m)) ∧
                   (AFMITMR( '1' ) @ #n)) ⇒
                  (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
               (∀ #m #n #r #s.
                 ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                      (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                     (InitD_OOBFlag( '0' ) @ #r)) ∧
                    (ResD_OOBFlag( '0' ) @ #s)) ∧
                   (AFMITMI( '1' ) @ #m)) ∧
                  (AFMITMR( '1' ) @ #n)) ⇒
                 (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
              (∀ #m #n #r #s.
                ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                     (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                    (InitD_OOBFlag( '0' ) @ #r)) ∧
                   (ResD_OOBFlag( '0' ) @ #s)) ∧
                  (AFMITMI( '1' ) @ #m)) ∧
                 (AFMITMR( '0' ) @ #n)) ⇒
                (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
             (∀ #m #n #r #s.
               ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                    (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                   (InitD_OOBFlag( '0' ) @ #r)) ∧
                  (ResD_OOBFlag( '0' ) @ #s)) ∧
                 (AFMITMI( '0' ) @ #m)) ∧
                (AFMITMR( '1' ) @ #n)) ⇒
               (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
            (∀ #m #n #r #s.
              ((((((InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
                   (ResD_IOCapability( 'DisplayOnly' ) @ #n)) ∧
                  (InitD_OOBFlag( '0' ) @ #r)) ∧
                 (ResD_OOBFlag( '0' ) @ #s)) ∧
                (AFMITMI( '1' ) @ #m)) ∧
               (AFMITMR( '1' ) @ #n)) ⇒
              (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
           (∀ #m #n #r #s.
             ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                  (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                 (InitD_OOBFlag( '0' ) @ #r)) ∧
                (ResD_OOBFlag( '0' ) @ #s)) ∧
               (AFMITMI( '1' ) @ #m)) ∧
              (AFMITMR( '0' ) @ #n)) ⇒
             (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
          (∀ #m #n #r #s.
            ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                 (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
                (InitD_OOBFlag( '0' ) @ #r)) ∧
               (ResD_OOBFlag( '0' ) @ #s)) ∧
              (AFMITMI( '0' ) @ #m)) ∧
             (AFMITMR( '1' ) @ #n)) ⇒
            (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
         (∀ #m #n #r #s.
           ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
                (ResD_IOCapability( 'DisplayYesNo' ) @ #n)) ∧
               (InitD_OOBFlag( '0' ) @ #r)) ∧
              (ResD_OOBFlag( '0' ) @ #s)) ∧
             (AFMITMI( '1' ) @ #m)) ∧
            (AFMITMR( '1' ) @ #n)) ⇒
           (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
        (∀ #m #n #r #s.
          ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
               (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
              (InitD_OOBFlag( '0' ) @ #r)) ∧
             (ResD_OOBFlag( '0' ) @ #s)) ∧
            (AFMITMI( '1' ) @ #m)) ∧
           (AFMITMR( '0' ) @ #n)) ⇒
          (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
       (∀ #m #n #r #s.
         ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
              (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
             (InitD_OOBFlag( '0' ) @ #r)) ∧
            (ResD_OOBFlag( '0' ) @ #s)) ∧
           (AFMITMI( '0' ) @ #m)) ∧
          (AFMITMR( '1' ) @ #n)) ⇒
         (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
      (∀ #m #n #r #s.
        ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
             (ResD_IOCapability( 'KeyboardOnly' ) @ #n)) ∧
            (InitD_OOBFlag( '0' ) @ #r)) ∧
           (ResD_OOBFlag( '0' ) @ #s)) ∧
          (AFMITMI( '1' ) @ #m)) ∧
         (AFMITMR( '1' ) @ #n)) ⇒
        (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
     (∀ #m #n #r #s.
       ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
            (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
           (InitD_OOBFlag( '0' ) @ #r)) ∧
          (ResD_OOBFlag( '0' ) @ #s)) ∧
         (AFMITMI( '1' ) @ #m)) ∧
        (AFMITMR( '0' ) @ #n)) ⇒
       (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
    (∀ #m #n #r #s.
      ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
           (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
          (InitD_OOBFlag( '0' ) @ #r)) ∧
         (ResD_OOBFlag( '0' ) @ #s)) ∧
        (AFMITMI( '0' ) @ #m)) ∧
       (AFMITMR( '1' ) @ #n)) ⇒
      (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))) ∧
   (∀ #m #n #r #s.
     ((((((InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
          (ResD_IOCapability( 'KeyboardDisplay' ) @ #n)) ∧
         (InitD_OOBFlag( '0' ) @ #r)) ∧
        (ResD_OOBFlag( '0' ) @ #s)) ∧
       (AFMITMI( '1' ) @ #m)) ∧
      (AFMITMR( '1' ) @ #n)) ⇒
     (∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)))"
/*
guarded formula characterizing all satisfying traces:
"(∃ #i #j. (FinishedInit( ) @ #i) ∧ (FinishedRes( ) @ #j)) ∧
 (∀ #m #n.
   (InitD_OOBFlag( '1' ) @ #m) ∧ (ResD_OOBFlag( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)) ∧
 (∀ #m #n.
   (InitD_OOBFlag( '0' ) @ #m) ∧ (ResD_OOBFlag( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)) ∧
 (∀ #m #n.
   (InitD_OOBFlag( '1' ) @ #m) ∧ (ResD_OOBFlag( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDOOB( ) @ #p) ∧ (ResDOOB( ) @ #q)) ∧
 (∀ #m #n #s #t.
   (InitD_OOBFlag( '0' ) @ #s) ∧
   (ResD_OOBFlag( '0' ) @ #t) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDJW( ) @ #p) ∧ (ResDJW( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDNC( ) @ #p) ∧ (ResDNC( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayYesNo' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'DisplayOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardDisplay' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'DisplayYesNo' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardOnly' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '0' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '0' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q)) ∧
 (∀ #m #n #r #s.
   (InitD_IOCapability( 'KeyboardOnly' ) @ #m) ∧
   (ResD_IOCapability( 'KeyboardDisplay' ) @ #n) ∧
   (InitD_OOBFlag( '0' ) @ #r) ∧
   (ResD_OOBFlag( '0' ) @ #s) ∧
   (AFMITMI( '1' ) @ #m) ∧
   (AFMITMR( '1' ) @ #n)
  ⇒
   ∃ #p #q. (InitDPE( ) @ #p) ∧ (ResDPE( ) @ #q))"
*/
simplify
solve( InitDSentEa( InitD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                    MacAddR, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                    ~Na, Nb, MacKeyI, LTKI
       ) ▶₀ #i )
  case InitDSendEa_case_09
  solve( !InitDKeySize( KeySizeInit ) ▶₀ #j )
    case ResDSResponseWithOOBflagR1
    solve( State_Res_OK( ResD, MacAddI, IOCapabilityI, OOBflagI, MITMI,
                         MacAddR, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR, ra,
                         rb, Na.1, ~Nb.1
           ) ▶₁ #j )
      case OOB_ResDOK_case_2
      solve( State_Scaned( InitD.2, MacAddI.2, IOCapabilityI.3, MITMI.3,
                           ~skI.2, ResD.1, MacAddR.2
             ) ▶₀ #k.1 )
        case Scan
        solve( OOB_InitDSentNonce( InitD.1, MacAddI, IOCapabilityI.1, OOBflagI,
                                   MITMI.1, MacAddR, IOCapabilityR.1, OOBflagR, MITMR.1, ~skI.1, DHpkR,
                                   DHKeyI, ra, rb, ~Na.2
               ) ▶₁ #p )
          case OOB_InitDSendNonce
          solve( State_ResD_InjectSecret( ResD, MacAddI, IOCapabilityI.1, OOBflagI,
                                          MITMI.1, MacAddR, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1,
                                          DHpkI.1, DHKeyR.1, ra, rb
                 ) ▶₁ #q )
            case OOB_ResDInjectSecretsWithOOBflagI1R0
            solve( !KU( ~MacAdd.1 ) @ #vk.1 )
              case Advertising
              solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                             ~Na, '0', IOCapabilityR, ~MacAdd.1, ~MacAdd)
                     ) @ #vk.19 )
                case ResDSendEb
                solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                               ~Na, ~Nb, ~rr.1, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                       ) @ #vk.20 )
                  case InitDSendEa
                  solve( !KU( ~MacAdd ) @ #vk.17 )
                    case InitDRequestWithOOBflagI1
                    solve( !KU( ~Na ) @ #vk.43 )
                      case OOB_InitDSendNonce
                      solve( !KU( ~Nb ) @ #vk.34 )
                        case OOB_ResDOK
                        solve( !KU( 'g'^~skR ) @ #vk.36 )
                          case ResDRecDHSendDH
                          solve( !KU( 'g'^~skI ) @ #vk.44 )
                            case InitDSendDH
                            SOLVED // trace found
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

predicate: A1( a, b, dhkey )<=>∀ #i.
 (Commit_Init( a, b, <'DHKey', dhkey> ) @ #i) ⇒
 ((∃ #j. Running_Res( b, a, <'DHKey', dhkey> ) @ #j) ∨
  (∃ #k. InitDJW( ) @ #k))

predicate: A2( a, b, dhkey )<=>∀ #i.
 (Commit_Res( a, b, <'DHKey', dhkey> ) @ #i) ⇒
 ((∃ #j. Running_Init( b, a, <'DHKey', dhkey> ) @ #j) ∨
  (∃ #k. ResDJW( ) @ #k))

predicate: A3( a, b, ltk )<=>∀ #i.
 (Commit_Init( a, b, <'LTK', ltk> ) @ #i) ⇒
 ((∃ #j. Running_Res( b, a, <'LTK', ltk> ) @ #j) ∨
  (∃ #k. InitDJW( ) @ #k))

predicate: A4( a, b, ltk )<=>∀ #i.
 (Commit_Res( a, b, <'LTK', ltk> ) @ #i) ⇒
 ((∃ #j. Running_Init( b, a, <'LTK', ltk> ) @ #j) ∨
  (∃ #k. ResDJW( ) @ #k))

predicate: A5( a, b, ltk )<=>∀ #i.
 (Commit_Init( a, b, <'LTK', ltk> ) @ #i) ⇒
 (∃ #j. Running_Res( b, a, <'LTK', ltk> ) @ #j)

predicate: A6( a, b, ltk )<=>∀ #i.
 (Commit_Res( a, b, <'LTK', ltk> ) @ #i) ⇒
 (∃ #j. Running_Init( b, a, <'LTK', ltk> ) @ #j)

lemma IAuthRwithDHKey:
  all-traces
  "∀ I R DHKey #i.
    (Commit_Init( I, R, <'DHKey', DHKey> ) @ #i) ⇒
    ((∃ #j. Running_Res( R, I, <'DHKey', DHKey> ) @ #j) ∨
     (∃ #k. InitDJW( ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ I R DHKey #i.
  (Commit_Init( I, R, <'DHKey', DHKey> ) @ #i)
 ∧
  (∀ #j. (Running_Res( R, I, <'DHKey', DHKey> ) @ #j) ⇒ ⊥) ∧
  (∀ #k. (InitDJW( ) @ #k) ⇒ ⊥)"
*/
simplify
solve( Commit_Init( I, R, <'DHKey', DHKey> ) @ #i )
  case InitDCheck
  solve( InitDSentEa( InitD, I, IOCapabilityI, OOBflagI, MITMI, R,
                      IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKey, ra, rb, ~Na, Nb,
                      MacKeyI, LTKI
         ) ▶₀ #i )
    case InitDSendEa_case_01
    by contradiction /* from formulas */
  next
    case InitDSendEa_case_02
    by contradiction /* from formulas */
  next
    case InitDSendEa_case_03
    by contradiction /* from formulas */
  next
    case InitDSendEa_case_04
    solve( !KU( f6(fst(f5(DHKey, ~Na, Nb, ~MacAdd, R)), Nb, ~Na, ~r,
                   'KeyboardOnly', R, ~MacAdd)
           ) @ #vk.15 )
      case c_f6
      by solve( !KU( ~r ) @ #vk.32 )
    qed
  next
    case InitDSendEa_case_05
    solve( !KU( f6(fst(f5(DHKey, ~Na, Nb, ~MacAdd, R)), Nb, ~Na, ~r,
                   'KeyboardDisplay', R, ~MacAdd)
           ) @ #vk.15 )
      case c_f6
      by solve( !KU( ~r ) @ #vk.32 )
    qed
  next
    case InitDSendEa_case_06
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        by solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1,
                                ~skI.1, ResD, MacAddR
                  ) ▶₀ #k.1 )
      qed
    qed
  next
    case InitDSendEa_case_07
    solve( !KU( f6(fst(f5(DHKey, ~Na, Nb, ~MacAdd, R)), Nb, ~Na, ~ri,
                   IOCapabilityR, R, ~MacAdd)
           ) @ #vk.11 )
      case ResDSendEb_case_1
      by contradiction /* from formulas */
    next
      case ResDSendEb_case_2
      by contradiction /* from formulas */
    next
      case c_f6
      by solve( !KU( ~ri ) @ #vk.26 )
    qed
  next
    case InitDSendEa_case_08
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        by solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1,
                                ~skI.1, ResD, MacAddR
                  ) ▶₀ #k.1 )
      qed
    qed
  next
    case InitDSendEa_case_09
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                             ResD, MacAddR
               ) ▶₀ #k.1 )
          case Scan
          solve( !KU( ~MacAdd.1 ) @ #vk.1 )
            case Advertising
            solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                           ~Na, '0', IOCapabilityR, ~MacAdd.1, ~MacAdd)
                   ) @ #vk.13 )
              case ResDSendEb
              by contradiction /* from formulas */
            next
              case c_f6
              solve( !KU( fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1))
                     ) @ #vk.37 )
                case c_fst
                solve( !KU( f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1) ) @ #vk.39 )
                  case c_f5
                  solve( !KU( 'g'^(~skI*~skR) ) @ #vk.40 )
                    case InitDSendDH
                    by solve( !KU( ~skR ) @ #vk.41 )
                  next
                    case ResDRecDHSendDH
                    by solve( !KU( ~skI ) @ #vk.44 )
                  next
                    case c_exp
                    by solve( !KU( ~skI ) @ #vk.43 )
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case InitDSendEa_case_10
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                             ResD, MacAddR
               ) ▶₀ #k.1 )
          case Scan
          solve( !KU( ~MacAdd.1 ) @ #vk.1 )
            case Advertising
            solve( !KU( f6(fst(f5(DHKey, ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb, ~Na, ~ri,
                           IOCapabilityR, ~MacAdd.1, ~MacAdd)
                   ) @ #vk.13 )
              case ResDSendEb_case_1
              by contradiction /* from formulas */
            next
              case ResDSendEb_case_2
              by contradiction /* from formulas */
            next
              case c_f6
              by solve( !KU( ~ri ) @ #vk.39 )
            qed
          qed
        qed
      qed
    qed
  next
    case InitDSendEa_case_11
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                             ResD, MacAddR
               ) ▶₀ #k.1 )
          case Scan
          solve( !KU( ~MacAdd.1 ) @ #vk.1 )
            case Advertising
            solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                           ~Na, ~ri, IOCapabilityR, ~MacAdd.1, ~MacAdd)
                   ) @ #vk.13 )
              case ResDSendEb_case_1
              by contradiction /* from formulas */
            next
              case ResDSendEb_case_2
              by contradiction /* from formulas */
            next
              case c_f6
              by solve( !KU( ~ri ) @ #vk.39 )
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma RAuthIwithDHKey:
  all-traces
  "∀ I R DHKey #i.
    (Commit_Res( R, I, <'DHKey', DHKey> ) @ #i) ⇒
    ((∃ #j. Running_Init( I, R, <'DHKey', DHKey> ) @ #j) ∨
     (∃ #k. ResDJW( ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ I R DHKey #i.
  (Commit_Res( R, I, <'DHKey', DHKey> ) @ #i)
 ∧
  (∀ #j. (Running_Init( I, R, <'DHKey', DHKey> ) @ #j) ⇒ ⊥) ∧
  (∀ #k. (ResDJW( ) @ #k) ⇒ ⊥)"
*/
simplify
solve( Commit_Res( R, I, <'DHKey', DHKey> ) @ #i )
  case ResDSendEb
  solve( !InitDKeySize( KeySizeInit ) ▶₀ #i )
    case ResDSResponse
    solve( State_Res_OK( ResD, I, IOCapabilityI, OOBflagI, MITMI, R,
                         IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKey, ra, rb, Na, ~Nb
           ) ▶₁ #i )
      case JW_ResDOK_case_1
      by contradiction /* from formulas */
    next
      case JW_ResDOK_case_2
      by contradiction /* from formulas */
    next
      case JW_ResDOK_case_3
      by contradiction /* from formulas */
    next
      case OOB_ResDOK
      solve( !KU( ~MacAdd ) @ #vk.6 )
        case Advertising
        solve( !KU( f6(fst(f5(DHKey, Na, ~Nb, I, ~MacAdd)), Na, ~Nb, ~rr,
                       IOCapabilityI, I, ~MacAdd)
               ) @ #vk.10 )
          case c_f6
          by solve( !KU( ~rr ) @ #vk.26 )
        qed
      qed
    next
      case PE_ResDCheckSendNonceOK_case_1
      solve( !KU( ~MacAdd ) @ #vk.8 )
        case Advertising
        solve( !KU( f6(fst(f5(DHKey, Na, ~Nb, I, ~MacAdd)), Na, ~Nb, ~r,
                       'KeyboardOnly', I, ~MacAdd)
               ) @ #vk.14 )
          case c_f6
          by solve( !KU( ~r ) @ #vk.32 )
        qed
      qed
    next
      case PE_ResDCheckSendNonceOK_case_2
      solve( !KU( ~MacAdd ) @ #vk.8 )
        case Advertising
        solve( !KU( f6(fst(f5(DHKey, Na, ~Nb, I, ~MacAdd)), Na, ~Nb, ~r,
                       'KeyboardDisplay', I, ~MacAdd)
               ) @ #vk.14 )
          case c_f6
          by solve( !KU( ~r ) @ #vk.32 )
        qed
      qed
    qed
  next
    case ResDSResponseWithOOBflagR1
    solve( State_Res_OK( ResD, I, IOCapabilityI, OOBflagI, MITMI, R,
                         IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKey, ra, rb, Na, ~Nb
           ) ▶₁ #i )
      case OOB_ResDOK_case_1
      solve( State_Scaned( InitD, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                           ResD, MacAddR
             ) ▶₀ #k )
        case Scan
        solve( !State_InitD_RevOOBInfo( MacAddR, rb, Cb ) ▶₁ #k )
          case InitDInOOBinfo
          solve( !KU( ~MacAdd.1 ) @ #vk.6 )
            case Advertising
            solve( !KU( f6(fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na,
                           ~Nb, '0', IOCapabilityI, ~MacAdd, ~MacAdd.1)
                   ) @ #vk.11 )
              case InitDSendEa
              by contradiction /* from formulas */
            next
              case c_f6
              solve( !KU( fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1))
                     ) @ #vk.26 )
                case c_fst
                solve( !KU( f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1) ) @ #vk.28 )
                  case c_f5
                  solve( !KU( 'g'^(~skI*~skR) ) @ #vk.29 )
                    case InitDSendDH
                    by solve( !KU( ~skR ) @ #vk.32 )
                  next
                    case ResDRecDHSendDH
                    by solve( !KU( ~skI ) @ #vk.30 )
                  next
                    case c_exp
                    by solve( !KU( ~skI ) @ #vk.32 )
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case OOB_ResDOK_case_2
      solve( State_Scaned( InitD, MacAddI, IOCapabilityI.1, MITMI.1, ~skI,
                           ResD, MacAddR
             ) ▶₀ #k )
        case Scan
        solve( !State_InitD_RevOOBInfo( MacAddR, rb, Cb ) ▶₁ #k )
          case InitDInOOBinfo
          solve( !KU( ~MacAdd.1 ) @ #vk.6 )
            case Advertising
            solve( !KU( f6(fst(f5(DHKey, Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na, ~Nb, ~rr,
                           IOCapabilityI, ~MacAdd, ~MacAdd.1)
                   ) @ #vk.11 )
              case InitDSendEa_case_1
              by contradiction /* from formulas */
            next
              case InitDSendEa_case_2
              by contradiction /* from formulas */
            next
              case c_f6
              by solve( !KU( ~rr ) @ #vk.28 )
            qed
          qed
        qed
      qed
    next
      case OOB_ResDOK_case_3
      solve( State_Scaned( InitD, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                           ResD, MacAddR
             ) ▶₀ #k )
        case Scan
        solve( !State_InitD_RevOOBInfo( MacAddR, rb, Cb ) ▶₁ #k )
          case InitDInOOBinfo
          solve( !KU( ~MacAdd.1 ) @ #vk.6 )
            case Advertising
            solve( !KU( f6(fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na,
                           ~Nb, ~rr, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                   ) @ #vk.11 )
              case InitDSendEa_case_1
              by contradiction /* from formulas */
            next
              case InitDSendEa_case_2
              by contradiction /* from formulas */
            next
              case c_f6
              by solve( !KU( ~rr ) @ #vk.28 )
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma IAuthRwithLTK:
  all-traces
  "∀ I R LTK #i.
    (Commit_Init( I, R, <'LTK', LTK> ) @ #i) ⇒
    ((∃ #j. Running_Res( R, I, <'LTK', LTK> ) @ #j) ∨
     (∃ #k. InitDJW( ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ I R LTK #i.
  (Commit_Init( I, R, <'LTK', LTK> ) @ #i)
 ∧
  (∀ #j. (Running_Res( R, I, <'LTK', LTK> ) @ #j) ⇒ ⊥) ∧
  (∀ #k. (InitDJW( ) @ #k) ⇒ ⊥)"
*/
simplify
solve( Commit_Init( I, R, <'LTK', LTK> ) @ #i )
  case InitDCheck
  solve( InitDSentEa( InitD, I, IOCapabilityI, OOBflagI, MITMI, R,
                      IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                      MacKeyI, LTK
         ) ▶₀ #i )
    case InitDSendEa_case_09
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                             ResD, MacAddR
               ) ▶₀ #k.1 )
          case Scan
          solve( !KU( ~MacAdd.1 ) @ #vk.1 )
            case Advertising
            solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                           ~Na, '0', IOCapabilityR, ~MacAdd.1, ~MacAdd)
                   ) @ #vk.13 )
              case ResDSendEb
              solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                             ~Na, ~Nb, ~rr.1, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                     ) @ #vk.43 )
                case InitDSendEa
                solve( !KU( ~MacAdd ) @ #vk.17 )
                  case InitDRequestWithOOBflagI1
                  solve( !KU( ~Na ) @ #vk.43 )
                    case OOB_InitDSendNonce
                    solve( !KU( ~Nb ) @ #vk.34 )
                      case OOB_ResDOK
                      solve( !KU( 'g'^~skR ) @ #vk.36 )
                        case ResDRecDHSendDH
                        solve( !KU( 'g'^~skI ) @ #vk.44 )
                          case InitDSendDH
                          SOLVED // trace found
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma RAuthIwithLTK:
  all-traces
  "∀ I R LTK #i.
    (Commit_Res( I, R, <'LTK', LTK> ) @ #i) ⇒
    ((∃ #j. Running_Init( R, I, <'LTK', LTK> ) @ #j) ∨
     (∃ #k. ResDJW( ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ I R LTK #i.
  (Commit_Res( I, R, <'LTK', LTK> ) @ #i)
 ∧
  (∀ #j. (Running_Init( R, I, <'LTK', LTK> ) @ #j) ⇒ ⊥) ∧
  (∀ #k. (ResDJW( ) @ #k) ⇒ ⊥)"
*/
simplify
solve( Commit_Res( I, R, <'LTK', LTK> ) @ #i )
  case ResDSendEb
  solve( !InitDKeySize( KeySizeInit ) ▶₀ #i )
    case ResDSResponseWithOOBflagR1
    solve( State_Res_OK( ResD, R, IOCapabilityI, OOBflagI, MITMI, I,
                         IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
           ) ▶₁ #i )
      case OOB_ResDOK_case_1
      solve( State_Scaned( InitD, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                           ResD, MacAddR
             ) ▶₀ #k )
        case Scan
        solve( !State_InitD_RevOOBInfo( MacAddR, rb, Cb ) ▶₁ #k )
          case InitDInOOBinfo
          solve( !KU( ~MacAdd.1 ) @ #vk.6 )
            case Advertising
            solve( !KU( f6(fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na,
                           ~Nb, '0', IOCapabilityI, ~MacAdd, ~MacAdd.1)
                   ) @ #vk.11 )
              case InitDSendEa
              solve( !KU( ~MacAdd ) @ #vk.11 )
                case InitDRequestWithOOBflagI1
                solve( !KU( ~Nb ) @ #vk.41 )
                  case OOB_ResDOK
                  solve( !KU( ~Na ) @ #vk.30 )
                    case OOB_InitDSendNonce
                    solve( !KU( 'g'^~skI ) @ #vk.31 )
                      case InitDSendDH
                      solve( !KU( 'g'^~skR ) @ #vk.42 )
                        case ResDRecDHSendDH
                        SOLVED // trace found
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma MITMP:
  all-traces
  "∀ I R #i.
    (MP( I, R ) @ #i) ⇒
    (¬(∃ LTKI LTKR #t1 #t2.
        (((¬(∀ #i.1.
              (Commit_Init( I, R, <'LTK', LTKI> ) @ #i.1) ⇒
              ((∃ #j. Running_Res( R, I, <'LTK', LTKI> ) @ #j) ∨
               (∃ #k. InitDJW( ) @ #k)))) ∧
          (¬(∀ #i.1.
              (Commit_Res( R, I, <'LTK', LTKR> ) @ #i.1) ⇒
              ((∃ #j. Running_Init( I, R, <'LTK', LTKR> ) @ #j) ∨
               (∃ #k. ResDJW( ) @ #k))))) ∧
         (K( LTKI ) @ #t1)) ∧
        (K( LTKR ) @ #t2)))"
/*
guarded formula characterizing all counter-examples:
"∃ I R #i.
  (MP( I, R ) @ #i)
 ∧
  ∃ LTKI LTKR #t1 #t2.
   (K( LTKI ) @ #t1) ∧ (K( LTKR ) @ #t2)
  ∧
   (∃ #i.1.
     (Commit_Init( I, R, <'LTK', LTKI> ) @ #i.1)
    ∧
     (∀ #j. (Running_Res( R, I, <'LTK', LTKI> ) @ #j) ⇒ ⊥) ∧
     (∀ #k. (InitDJW( ) @ #k) ⇒ ⊥)) ∧
   (∃ #i.1.
     (Commit_Res( R, I, <'LTK', LTKR> ) @ #i.1)
    ∧
     (∀ #j. (Running_Init( I, R, <'LTK', LTKR> ) @ #j) ⇒ ⊥) ∧
     (∀ #k. (ResDJW( ) @ #k) ⇒ ⊥))"
*/
simplify
solve( MP( I, R ) @ #i )
  case InitDCheck
  solve( InitDSentEa( InitD, I, IOCapabilityI, OOBflagI, MITMI, R,
                      IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                      MacKeyI, LTKI
         ) ▶₀ #i )
    case InitDSendEa_case_01
    by contradiction /* from formulas */
  next
    case InitDSendEa_case_02
    by contradiction /* from formulas */
  next
    case InitDSendEa_case_03
    by contradiction /* from formulas */
  next
    case InitDSendEa_case_04
    solve( Commit_Init( ~MacAdd, R, <'LTK', LTKI> ) @ #i.1 )
      case InitDCheck
      solve( InitDSentEa( InitD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI, R,
                          IOCapabilityR, OOBflagR, MITMR.1, ~skI.1, DHpkR.1, DHKeyI.1, ra, rb,
                          ~Na.1, Nb.1, MacKeyI, LTKI
             ) ▶₀ #i.1 )
        case InitDSendEa
        solve( Commit_Res( R, ~MacAdd, <'LTK', LTKR> ) @ #i.1 )
          case ResDSendEb
          solve( !InitDKeySize( KeySizeInit ) ▶₀ #i.1 )
            case ResDSResponseWithOOBflagR1
            solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI, R,
                                 IOCapabilityR, OOBflagR, MITMR.1, ~skR, DHpkI, DHKeyR, ra, rb, Na.1,
                                 ~Nb.1
                   ) ▶₁ #i.1 )
              case OOB_ResDOK_case_1
              by solve( State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI.1,
                                      ResD, MacAddR
                        ) ▶₀ #k )
            next
              case OOB_ResDOK_case_2
              by solve( State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI.1,
                                      ResD, MacAddR
                        ) ▶₀ #k )
            next
              case OOB_ResDOK_case_3
              by solve( State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI.1,
                                      ResD, MacAddR
                        ) ▶₀ #k )
            qed
          qed
        qed
      qed
    qed
  next
    case InitDSendEa_case_05
    solve( Commit_Init( ~MacAdd, R, <'LTK', LTKI> ) @ #i.1 )
      case InitDCheck
      solve( InitDSentEa( InitD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI, R,
                          IOCapabilityR, OOBflagR, MITMR.1, ~skI.1, DHpkR.1, DHKeyI.1, ra, rb,
                          ~Na.1, Nb.1, MacKeyI, LTKI
             ) ▶₀ #i.1 )
        case InitDSendEa
        solve( Commit_Res( R, ~MacAdd, <'LTK', LTKR> ) @ #i.1 )
          case ResDSendEb
          solve( !InitDKeySize( KeySizeInit ) ▶₀ #i.1 )
            case ResDSResponseWithOOBflagR1
            solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI, R,
                                 IOCapabilityR, OOBflagR, MITMR.1, ~skR, DHpkI, DHKeyR, ra, rb, Na.1,
                                 ~Nb.1
                   ) ▶₁ #i.1 )
              case OOB_ResDOK_case_1
              by solve( State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI.1,
                                      ResD, MacAddR
                        ) ▶₀ #k )
            next
              case OOB_ResDOK_case_2
              by solve( State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI.1,
                                      ResD, MacAddR
                        ) ▶₀ #k )
            next
              case OOB_ResDOK_case_3
              by solve( State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI.1,
                                      ResD, MacAddR
                        ) ▶₀ #k )
            qed
          qed
        qed
      qed
    qed
  next
    case InitDSendEa_case_06
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        by solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1,
                                ~skI.1, ResD, MacAddR
                  ) ▶₀ #k.1 )
      qed
    qed
  next
    case InitDSendEa_case_07
    solve( Commit_Init( ~MacAdd, R, <'LTK', LTKI> ) @ #i.1 )
      case InitDCheck
      solve( InitDSentEa( InitD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI, R,
                          IOCapabilityR.1, OOBflagR, MITMR.1, ~skI.1, DHpkR.1, DHKeyI.1, ra, rb,
                          ~Na.1, Nb.1, MacKeyI, LTKI
             ) ▶₀ #i.1 )
        case InitDSendEa
        solve( Commit_Res( R, ~MacAdd, <'LTK', LTKR> ) @ #i.1 )
          case ResDSendEb
          solve( !InitDKeySize( KeySizeInit ) ▶₀ #i.1 )
            case ResDSResponseWithOOBflagR1
            solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI, R,
                                 IOCapabilityR.1, OOBflagR, MITMR.1, ~skR, DHpkI, DHKeyR, ra, rb, Na.1,
                                 ~Nb.1
                   ) ▶₁ #i.1 )
              case OOB_ResDOK_case_1
              by solve( State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI.1,
                                      ResD, MacAddR
                        ) ▶₀ #k )
            next
              case OOB_ResDOK_case_2
              by solve( State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI.1,
                                      ResD, MacAddR
                        ) ▶₀ #k )
            next
              case OOB_ResDOK_case_3
              by solve( State_Scaned( InitD, MacAddI, IOCapabilityI, MITMI, ~skI.1,
                                      ResD, MacAddR
                        ) ▶₀ #k )
            qed
          qed
        qed
      qed
    qed
  next
    case InitDSendEa_case_08
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        by solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1,
                                ~skI.1, ResD, MacAddR
                  ) ▶₀ #k.1 )
      qed
    qed
  next
    case InitDSendEa_case_09
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                             ResD, MacAddR
               ) ▶₀ #k.1 )
          case Scan
          solve( Commit_Init( ~MacAdd, ~MacAdd.1, <'LTK', LTKI> ) @ #i.1 )
            case InitDCheck
            solve( InitDSentEa( InitD.1, ~MacAdd, IOCapabilityI.1, OOBflagI.1,
                                MITMI.1, ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skI.1, DHpkR,
                                DHKeyI, ra, rb, ~Na.1, Nb.1, MacKeyI, LTKI
                   ) ▶₀ #i.1 )
              case InitDSendEa
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.1 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.1 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI.1, OOBflagI.1, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR,
                                       ra, rb, Na.1, ~Nb.1
                         ) ▶₁ #i.1 )
                    case OOB_ResDOK_case_1
                    solve( !KU( ~MacAdd.1 ) @ #vk.3 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                                     ~Na, '0', IOCapabilityR, ~MacAdd.1, ~MacAdd)
                             ) @ #vk.21 )
                        case c_f6
                        solve( !KU( fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1))
                               ) @ #vk.47 )
                          case c_fst
                          solve( !KU( f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1) ) @ #vk.49 )
                            case c_f5
                            solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                              case InitDSendDH
                              by solve( !KU( ~skR ) @ #vk.51 )
                            next
                              case ResDRecDHSendDH
                              by solve( !KU( ~skI ) @ #vk.51 )
                            next
                              case c_exp
                              by solve( !KU( ~skI ) @ #vk.53 )
                            qed
                          qed
                        qed
                      qed
                    qed
                  next
                    case OOB_ResDOK_case_2
                    solve( !KU( ~MacAdd.1 ) @ #vk.3 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                                     ~Na, '0', IOCapabilityR, ~MacAdd.1, ~MacAdd)
                             ) @ #vk.21 )
                        case ResDSendEb
                        solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                  ~MacAdd.1)),
                                           KeySizeRes)
                               ) @ #vk.11 )
                          case c_resize
                          solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                 ) @ #vk.48 )
                            case c_snd
                            solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                   ) @ #vk.49 )
                              case c_f5
                              solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                                case InitDSendDH
                                by solve( !KU( ~skR ) @ #vk.51 )
                              next
                                case ResDRecDHSendDH
                                by solve( !KU( ~skI ) @ #vk.51 )
                              next
                                case c_exp
                                by solve( !KU( ~skI ) @ #vk.53 )
                              qed
                            qed
                          qed
                        next
                          case oracle
                          solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                    ~MacAdd.1)),
                                             KeySizeInit)
                                 ) @ #vk.17 )
                            case c_resize
                            solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                   ) @ #vk.49 )
                              case c_snd
                              solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                     ) @ #vk.50 )
                                case c_f5
                                solve( !KU( 'g'^(~skI*~skR) ) @ #vk.51 )
                                  case InitDSendDH
                                  by solve( !KU( ~skR ) @ #vk.52 )
                                next
                                  case ResDRecDHSendDH
                                  by solve( !KU( ~skI ) @ #vk.52 )
                                next
                                  case c_exp
                                  by solve( !KU( ~skI ) @ #vk.54 )
                                qed
                              qed
                            qed
                          next
                            case oracle
                            by contradiction /* from formulas */
                          qed
                        qed
                      next
                        case c_f6
                        solve( !KU( fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1))
                               ) @ #vk.48 )
                          case c_fst
                          solve( !KU( f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1) ) @ #vk.50 )
                            case c_f5
                            solve( !KU( 'g'^(~skI*~skR) ) @ #vk.51 )
                              case InitDSendDH
                              by solve( !KU( ~skR ) @ #vk.52 )
                            next
                              case ResDRecDHSendDH
                              by solve( !KU( ~skI ) @ #vk.52 )
                            next
                              case c_exp
                              by solve( !KU( ~skI ) @ #vk.54 )
                            qed
                          qed
                        qed
                      qed
                    qed
                  next
                    case OOB_ResDOK_case_3
                    solve( !KU( ~MacAdd.1 ) @ #vk.3 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                                     ~Na, '0', IOCapabilityR, ~MacAdd.1, ~MacAdd)
                             ) @ #vk.21 )
                        case c_f6
                        solve( !KU( fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1))
                               ) @ #vk.48 )
                          case c_fst
                          solve( !KU( f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1) ) @ #vk.50 )
                            case c_f5
                            solve( !KU( 'g'^(~skI*~skR) ) @ #vk.51 )
                              case InitDSendDH
                              by solve( !KU( ~skR ) @ #vk.52 )
                            next
                              case ResDRecDHSendDH
                              by solve( !KU( ~skI ) @ #vk.52 )
                            next
                              case c_exp
                              by solve( !KU( ~skI ) @ #vk.54 )
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case InitDSendEa_case_10
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                             ResD, MacAddR
               ) ▶₀ #k.1 )
          case Scan
          solve( Commit_Init( ~MacAdd, ~MacAdd.1, <'LTK', LTKI> ) @ #i.1 )
            case InitDCheck
            solve( InitDSentEa( InitD.1, ~MacAdd, IOCapabilityI.1, OOBflagI.1,
                                MITMI.1, ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skI.1, DHpkR.1,
                                DHKeyI.1, ra, rb, ~Na.1, Nb.1, MacKeyI, LTKI
                   ) ▶₀ #i.1 )
              case InitDSendEa
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.1 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.1 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI.1, OOBflagI.1, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR,
                                       ra, rb, Na.1, ~Nb.1
                         ) ▶₁ #i.1 )
                    case OOB_ResDOK_case_1
                    solve( !KU( ~MacAdd.1 ) @ #vk.3 )
                      case Advertising
                      solve( !KU( f6(fst(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb, ~Na,
                                     ~ri, IOCapabilityR, ~MacAdd.1, ~MacAdd)
                             ) @ #vk.21 )
                        case ResDSendEb
                        solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                  ~MacAdd.1)),
                                           KeySizeRes)
                               ) @ #vk.11 )
                          case c_resize
                          solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                 ) @ #vk.48 )
                            case c_snd
                            solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                   ) @ #vk.49 )
                              case c_f5
                              solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                                case InitDSendDH
                                by solve( !KU( ~skR ) @ #vk.51 )
                              next
                                case ResDRecDHSendDH
                                by solve( !KU( ~skI ) @ #vk.51 )
                              next
                                case c_exp
                                by solve( !KU( ~skI ) @ #vk.53 )
                              qed
                            qed
                          qed
                        next
                          case oracle
                          solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                    ~MacAdd.1)),
                                             KeySizeInit)
                                 ) @ #vk.17 )
                            case c_resize
                            solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                   ) @ #vk.49 )
                              case c_snd
                              solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                     ) @ #vk.50 )
                                case c_f5
                                solve( !KU( 'g'^(~skI*~skR) ) @ #vk.51 )
                                  case InitDSendDH
                                  by solve( !KU( ~skR ) @ #vk.52 )
                                next
                                  case ResDRecDHSendDH
                                  by solve( !KU( ~skI ) @ #vk.52 )
                                next
                                  case c_exp
                                  by solve( !KU( ~skI ) @ #vk.54 )
                                qed
                              qed
                            qed
                          next
                            case oracle
                            by contradiction /* from formulas */
                          qed
                        qed
                      next
                        case c_f6
                        by solve( !KU( ~ri ) @ #vk.50 )
                      qed
                    qed
                  next
                    case OOB_ResDOK_case_2
                    solve( !KU( ~MacAdd.1 ) @ #vk.3 )
                      case Advertising
                      solve( !KU( f6(fst(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb, ~Na,
                                     ~ri, IOCapabilityR, ~MacAdd.1, ~MacAdd)
                             ) @ #vk.21 )
                        case c_f6
                        by solve( !KU( ~ri ) @ #vk.49 )
                      qed
                    qed
                  next
                    case OOB_ResDOK_case_3
                    solve( !KU( ~MacAdd.1 ) @ #vk.3 )
                      case Advertising
                      solve( !KU( f6(fst(f5(DHKeyI, ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb, ~Na,
                                     ~ri, IOCapabilityR, ~MacAdd.1, ~MacAdd)
                             ) @ #vk.21 )
                        case ResDSendEb
                        solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                  ~MacAdd.1)),
                                           KeySizeRes)
                               ) @ #vk.11 )
                          case c_resize
                          solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                 ) @ #vk.47 )
                            case c_snd
                            solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                   ) @ #vk.48 )
                              case c_f5
                              solve( !KU( 'g'^(~skI*~skR) ) @ #vk.49 )
                                case InitDSendDH
                                by solve( !KU( ~skR ) @ #vk.50 )
                              next
                                case ResDRecDHSendDH
                                by solve( !KU( ~skI ) @ #vk.50 )
                              next
                                case c_exp
                                by solve( !KU( ~skI ) @ #vk.52 )
                              qed
                            qed
                          qed
                        next
                          case oracle
                          solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                    ~MacAdd.1)),
                                             KeySizeInit)
                                 ) @ #vk.17 )
                            case c_resize
                            solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                   ) @ #vk.48 )
                              case c_snd
                              solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                     ) @ #vk.49 )
                                case c_f5
                                solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                                  case InitDSendDH
                                  by solve( !KU( ~skR ) @ #vk.51 )
                                next
                                  case ResDRecDHSendDH
                                  by solve( !KU( ~skI ) @ #vk.51 )
                                next
                                  case c_exp
                                  by solve( !KU( ~skI ) @ #vk.53 )
                                qed
                              qed
                            qed
                          next
                            case oracle
                            by contradiction /* from formulas */
                          qed
                        qed
                      next
                        case c_f6
                        by solve( !KU( ~ri ) @ #vk.49 )
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case InitDSendEa_case_11
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                             ResD, MacAddR
               ) ▶₀ #k.1 )
          case Scan
          solve( Commit_Init( ~MacAdd, ~MacAdd.1, <'LTK', LTKI> ) @ #i.1 )
            case InitDCheck
            solve( InitDSentEa( InitD.1, ~MacAdd, IOCapabilityI.1, OOBflagI.1,
                                MITMI.1, ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skI.1, DHpkR,
                                DHKeyI, ra, rb, ~Na.1, Nb.1, MacKeyI, LTKI
                   ) ▶₀ #i.1 )
              case InitDSendEa
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.1 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.1 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI.1, OOBflagI.1, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR,
                                       ra, rb, Na.1, ~Nb.1
                         ) ▶₁ #i.1 )
                    case OOB_ResDOK_case_1
                    solve( !KU( ~MacAdd.1 ) @ #vk.3 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                                     ~Na, ~ri, IOCapabilityR, ~MacAdd.1, ~MacAdd)
                             ) @ #vk.21 )
                        case ResDSendEb
                        solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                  ~MacAdd.1)),
                                           KeySizeRes)
                               ) @ #vk.11 )
                          case c_resize
                          solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                 ) @ #vk.48 )
                            case c_snd
                            solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                   ) @ #vk.49 )
                              case c_f5
                              solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                                case InitDSendDH
                                by solve( !KU( ~skR ) @ #vk.51 )
                              next
                                case ResDRecDHSendDH
                                by solve( !KU( ~skI ) @ #vk.51 )
                              next
                                case c_exp
                                by solve( !KU( ~skI ) @ #vk.53 )
                              qed
                            qed
                          qed
                        next
                          case oracle
                          solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                    ~MacAdd.1)),
                                             KeySizeInit)
                                 ) @ #vk.17 )
                            case c_resize
                            solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                   ) @ #vk.49 )
                              case c_snd
                              solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                     ) @ #vk.50 )
                                case c_f5
                                solve( !KU( 'g'^(~skI*~skR) ) @ #vk.51 )
                                  case InitDSendDH
                                  by solve( !KU( ~skR ) @ #vk.52 )
                                next
                                  case ResDRecDHSendDH
                                  by solve( !KU( ~skI ) @ #vk.52 )
                                next
                                  case c_exp
                                  by solve( !KU( ~skI ) @ #vk.54 )
                                qed
                              qed
                            qed
                          next
                            case oracle
                            by contradiction /* from formulas */
                          qed
                        qed
                      next
                        case c_f6
                        by solve( !KU( ~ri ) @ #vk.50 )
                      qed
                    qed
                  next
                    case OOB_ResDOK_case_2
                    solve( !KU( ~MacAdd.1 ) @ #vk.3 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                                     ~Na, ~ri, IOCapabilityR, ~MacAdd.1, ~MacAdd)
                             ) @ #vk.21 )
                        case c_f6
                        by solve( !KU( ~ri ) @ #vk.49 )
                      qed
                    qed
                  next
                    case OOB_ResDOK_case_3
                    solve( !KU( ~MacAdd.1 ) @ #vk.3 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                                     ~Na, ~ri, IOCapabilityR, ~MacAdd.1, ~MacAdd)
                             ) @ #vk.21 )
                        case ResDSendEb
                        solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                  ~MacAdd.1)),
                                           KeySizeRes)
                               ) @ #vk.11 )
                          case c_resize
                          solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                 ) @ #vk.47 )
                            case c_snd
                            solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                   ) @ #vk.48 )
                              case c_f5
                              solve( !KU( 'g'^(~skI*~skR) ) @ #vk.49 )
                                case InitDSendDH
                                by solve( !KU( ~skR ) @ #vk.50 )
                              next
                                case ResDRecDHSendDH
                                by solve( !KU( ~skI ) @ #vk.50 )
                              next
                                case c_exp
                                by solve( !KU( ~skI ) @ #vk.52 )
                              qed
                            qed
                          qed
                        next
                          case oracle
                          solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                    ~MacAdd.1)),
                                             KeySizeInit)
                                 ) @ #vk.17 )
                            case c_resize
                            solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                   ) @ #vk.48 )
                              case c_snd
                              solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                     ) @ #vk.49 )
                                case c_f5
                                solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                                  case InitDSendDH
                                  by solve( !KU( ~skR ) @ #vk.51 )
                                next
                                  case ResDRecDHSendDH
                                  by solve( !KU( ~skI ) @ #vk.51 )
                                next
                                  case c_exp
                                  by solve( !KU( ~skI ) @ #vk.53 )
                                qed
                              qed
                            qed
                          next
                            case oracle
                            by contradiction /* from formulas */
                          qed
                        qed
                      next
                        case c_f6
                        by solve( !KU( ~ri ) @ #vk.49 )
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
next
  case ResDSendEb
  solve( !InitDKeySize( KeySizeInit ) ▶₀ #i )
    case ResDSResponse
    solve( State_Res_OK( ResD, I, IOCapabilityI, OOBflagI, MITMI, R,
                         IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
           ) ▶₁ #i )
      case JW_ResDOK_case_1
      by contradiction /* from formulas */
    next
      case JW_ResDOK_case_2
      by contradiction /* from formulas */
    next
      case JW_ResDOK_case_3
      by contradiction /* from formulas */
    next
      case OOB_ResDOK
      solve( Commit_Init( I, ~MacAdd, <'LTK', LTKI> ) @ #i.1 )
        case InitDCheck
        by solve( InitDSentEa( InitD.1, I, IOCapabilityI.1, OOBflagI, MITMI.1,
                               ~MacAdd, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                               ~Na.1, Nb.1, MacKeyI, LTKI
                  ) ▶₀ #i.1 )
      qed
    next
      case PE_ResDCheckSendNonceOK_case_1
      solve( Commit_Init( I, ~MacAdd, <'LTK', LTKI> ) @ #i.1 )
        case InitDCheck
        by solve( InitDSentEa( InitD.1, I, IOCapabilityI, OOBflagI, MITMI.1,
                               ~MacAdd, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                               ~Na.1, Nb.1, MacKeyI, LTKI
                  ) ▶₀ #i.1 )
      qed
    next
      case PE_ResDCheckSendNonceOK_case_2
      solve( Commit_Init( I, ~MacAdd, <'LTK', LTKI> ) @ #i.1 )
        case InitDCheck
        by solve( InitDSentEa( InitD.1, I, IOCapabilityI, OOBflagI, MITMI.1,
                               ~MacAdd, IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb,
                               ~Na.1, Nb.1, MacKeyI, LTKI
                  ) ▶₀ #i.1 )
      qed
    qed
  next
    case ResDSResponseWithOOBflagR1
    solve( State_Res_OK( ResD, I, IOCapabilityI, OOBflagI, MITMI, R,
                         IOCapabilityR, OOBflagR, MITMR, ~skR, DHpkI, DHKeyR, ra, rb, Na, ~Nb
           ) ▶₁ #i )
      case OOB_ResDOK_case_1
      solve( State_Scaned( InitD, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                           ResD, MacAddR
             ) ▶₀ #k )
        case Scan
        solve( !State_InitD_RevOOBInfo( MacAddR, rb, Cb ) ▶₁ #k )
          case InitDInOOBinfo
          solve( Commit_Init( ~MacAdd, ~MacAdd.1, <'LTK', LTKI> ) @ #i.1 )
            case InitDCheck
            solve( InitDSentEa( InitD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                ~MacAdd.1, IOCapabilityR, OOBflagR, MITMR, ~skI.1, DHpkR, DHKeyI, ra, rb,
                                ~Na.1, Nb.1, MacKeyI, LTKI
                   ) ▶₀ #i.1 )
              case InitDSendEa_case_1
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.2 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.2 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR,
                                       ra, rb, Na.2, ~Nb.2
                         ) ▶₁ #i.2 )
                    case OOB_ResDOK
                    solve( !KU( ~MacAdd.1 ) @ #vk.16 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na,
                                     ~Nb, '0', IOCapabilityI, ~MacAdd, ~MacAdd.1)
                             ) @ #vk.21 )
                        case c_f6
                        solve( !KU( fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1))
                               ) @ #vk.47 )
                          case c_fst
                          solve( !KU( f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1) ) @ #vk.49 )
                            case c_f5
                            solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                              case InitDSendDH
                              by solve( !KU( ~skR ) @ #vk.51 )
                            next
                              case ResDRecDHSendDH
                              by solve( !KU( ~skI ) @ #vk.51 )
                            next
                              case c_exp
                              by solve( !KU( ~skI ) @ #vk.53 )
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            next
              case InitDSendEa_case_2
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.2 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.2 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR,
                                       ra, rb, Na.2, ~Nb.2
                         ) ▶₁ #i.2 )
                    case OOB_ResDOK
                    solve( !KU( ~MacAdd.1 ) @ #vk.16 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na,
                                     ~Nb, '0', IOCapabilityI, ~MacAdd, ~MacAdd.1)
                             ) @ #vk.21 )
                        case InitDSendEa
                        solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                       ~Nb, ~Na, ~ri.1, IOCapabilityR, ~MacAdd.1, ~MacAdd)
                               ) @ #vk.36 )
                          case ResDSendEb
                          solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                    ~MacAdd.1)),
                                             KeySizeRes)
                                 ) @ #vk.16 )
                            case c_resize
                            solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                   ) @ #vk.47 )
                              case c_snd
                              solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                     ) @ #vk.48 )
                                case c_f5
                                solve( !KU( 'g'^(~skI*~skR) ) @ #vk.49 )
                                  case InitDSendDH
                                  by solve( !KU( ~skR ) @ #vk.50 )
                                next
                                  case ResDRecDHSendDH
                                  by solve( !KU( ~skI ) @ #vk.50 )
                                next
                                  case c_exp
                                  by solve( !KU( ~skI ) @ #vk.52 )
                                qed
                              qed
                            qed
                          next
                            case oracle
                            solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                      ~MacAdd.1)),
                                               KeySizeInit)
                                   ) @ #vk.18 )
                              case c_resize
                              solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                     ) @ #vk.48 )
                                case c_snd
                                solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                       ) @ #vk.49 )
                                  case c_f5
                                  solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                                    case InitDSendDH
                                    by solve( !KU( ~skR ) @ #vk.51 )
                                  next
                                    case ResDRecDHSendDH
                                    by solve( !KU( ~skI ) @ #vk.51 )
                                  next
                                    case c_exp
                                    by solve( !KU( ~skI ) @ #vk.53 )
                                  qed
                                qed
                              qed
                            next
                              case oracle
                              by contradiction /* from formulas */
                            qed
                          qed
                        next
                          case c_f6
                          by solve( !KU( ~ri.1 ) @ #vk.49 )
                        qed
                      next
                        case c_f6
                        solve( !KU( fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1))
                               ) @ #vk.48 )
                          case c_fst
                          solve( !KU( f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1) ) @ #vk.50 )
                            case c_f5
                            solve( !KU( 'g'^(~skI*~skR) ) @ #vk.51 )
                              case InitDSendDH
                              by solve( !KU( ~skR ) @ #vk.52 )
                            next
                              case ResDRecDHSendDH
                              by solve( !KU( ~skI ) @ #vk.52 )
                            next
                              case c_exp
                              by solve( !KU( ~skI ) @ #vk.54 )
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            next
              case InitDSendEa_case_3
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.2 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.2 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR,
                                       ra, rb, Na.2, ~Nb.2
                         ) ▶₁ #i.2 )
                    case OOB_ResDOK
                    solve( !KU( ~MacAdd.1 ) @ #vk.16 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na,
                                     ~Nb, '0', IOCapabilityI, ~MacAdd, ~MacAdd.1)
                             ) @ #vk.21 )
                        case c_f6
                        solve( !KU( fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1))
                               ) @ #vk.48 )
                          case c_fst
                          solve( !KU( f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1) ) @ #vk.50 )
                            case c_f5
                            solve( !KU( 'g'^(~skI*~skR) ) @ #vk.51 )
                              case InitDSendDH
                              by solve( !KU( ~skR ) @ #vk.52 )
                            next
                              case ResDRecDHSendDH
                              by solve( !KU( ~skI ) @ #vk.52 )
                            next
                              case c_exp
                              by solve( !KU( ~skI ) @ #vk.54 )
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case OOB_ResDOK_case_2
      solve( State_Scaned( InitD, MacAddI, IOCapabilityI.1, MITMI.1, ~skI,
                           ResD, MacAddR
             ) ▶₀ #k )
        case Scan
        solve( !State_InitD_RevOOBInfo( MacAddR, rb, Cb ) ▶₁ #k )
          case InitDInOOBinfo
          solve( Commit_Init( ~MacAdd, ~MacAdd.1, <'LTK', LTKI> ) @ #i.1 )
            case InitDCheck
            solve( InitDSentEa( InitD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                ~MacAdd.1, IOCapabilityR, OOBflagR, MITMR, ~skI.1, DHpkR, DHKeyI, ra, rb,
                                ~Na.1, Nb.1, MacKeyI, LTKI
                   ) ▶₀ #i.1 )
              case InitDSendEa_case_1
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.2 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.2 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI.1,
                                       DHKeyR.1, ra, rb, Na.2, ~Nb.2
                         ) ▶₁ #i.2 )
                    case OOB_ResDOK
                    solve( !KU( ~MacAdd.1 ) @ #vk.16 )
                      case Advertising
                      solve( !KU( f6(fst(f5(DHKeyR, Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na, ~Nb,
                                     ~rr, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                             ) @ #vk.21 )
                        case InitDSendEa
                        solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                       ~Nb, ~Na, '0', IOCapabilityR, ~MacAdd.1, ~MacAdd)
                               ) @ #vk.36 )
                          case ResDSendEb
                          solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                    ~MacAdd.1)),
                                             KeySizeRes)
                                 ) @ #vk.16 )
                            case c_resize
                            solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                   ) @ #vk.47 )
                              case c_snd
                              solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                     ) @ #vk.48 )
                                case c_f5
                                solve( !KU( 'g'^(~skI*~skR) ) @ #vk.49 )
                                  case InitDSendDH
                                  by solve( !KU( ~skR ) @ #vk.50 )
                                next
                                  case ResDRecDHSendDH
                                  by solve( !KU( ~skI ) @ #vk.50 )
                                next
                                  case c_exp
                                  by solve( !KU( ~skI ) @ #vk.52 )
                                qed
                              qed
                            qed
                          next
                            case oracle
                            solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                      ~MacAdd.1)),
                                               KeySizeInit)
                                   ) @ #vk.18 )
                              case c_resize
                              solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                     ) @ #vk.48 )
                                case c_snd
                                solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                       ) @ #vk.49 )
                                  case c_f5
                                  solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                                    case InitDSendDH
                                    by solve( !KU( ~skR ) @ #vk.51 )
                                  next
                                    case ResDRecDHSendDH
                                    by solve( !KU( ~skI ) @ #vk.51 )
                                  next
                                    case c_exp
                                    by solve( !KU( ~skI ) @ #vk.53 )
                                  qed
                                qed
                              qed
                            next
                              case oracle
                              by contradiction /* from formulas */
                            qed
                          qed
                        next
                          case c_f6
                          solve( !KU( fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                 ) @ #vk.48 )
                            case c_fst
                            solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                   ) @ #vk.49 )
                              case c_f5
                              solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                                case InitDSendDH
                                by solve( !KU( ~skR ) @ #vk.51 )
                              next
                                case ResDRecDHSendDH
                                by solve( !KU( ~skI ) @ #vk.51 )
                              next
                                case c_exp
                                by solve( !KU( ~skI ) @ #vk.53 )
                              qed
                            qed
                          qed
                        qed
                      next
                        case c_f6
                        by solve( !KU( ~rr ) @ #vk.50 )
                      qed
                    qed
                  qed
                qed
              qed
            next
              case InitDSendEa_case_2
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.2 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.2 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI.1,
                                       DHKeyR.1, ra, rb, Na.2, ~Nb.2
                         ) ▶₁ #i.2 )
                    case OOB_ResDOK
                    solve( !KU( ~MacAdd.1 ) @ #vk.16 )
                      case Advertising
                      solve( !KU( f6(fst(f5(DHKeyR, Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na, ~Nb,
                                     ~rr, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                             ) @ #vk.21 )
                        case c_f6
                        by solve( !KU( ~rr ) @ #vk.49 )
                      qed
                    qed
                  qed
                qed
              qed
            next
              case InitDSendEa_case_3
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.2 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.2 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI.1,
                                       DHKeyR.1, ra, rb, Na.2, ~Nb.2
                         ) ▶₁ #i.2 )
                    case OOB_ResDOK
                    solve( !KU( ~MacAdd.1 ) @ #vk.16 )
                      case Advertising
                      solve( !KU( f6(fst(f5(DHKeyR, Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na, ~Nb,
                                     ~rr, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                             ) @ #vk.21 )
                        case InitDSendEa
                        solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                       ~Nb, ~Na, ~ri.1, IOCapabilityR, ~MacAdd.1, ~MacAdd)
                               ) @ #vk.39 )
                          case c_f6
                          by solve( !KU( ~ri.1 ) @ #vk.48 )
                        qed
                      next
                        case c_f6
                        by solve( !KU( ~rr ) @ #vk.49 )
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case OOB_ResDOK_case_3
      solve( State_Scaned( InitD, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                           ResD, MacAddR
             ) ▶₀ #k )
        case Scan
        solve( !State_InitD_RevOOBInfo( MacAddR, rb, Cb ) ▶₁ #k )
          case InitDInOOBinfo
          solve( Commit_Init( ~MacAdd, ~MacAdd.1, <'LTK', LTKI> ) @ #i.1 )
            case InitDCheck
            solve( InitDSentEa( InitD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                ~MacAdd.1, IOCapabilityR, OOBflagR, MITMR, ~skI.1, DHpkR, DHKeyI, ra, rb,
                                ~Na.1, Nb.1, MacKeyI, LTKI
                   ) ▶₀ #i.1 )
              case InitDSendEa_case_1
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.2 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.2 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR,
                                       ra, rb, Na.2, ~Nb.2
                         ) ▶₁ #i.2 )
                    case OOB_ResDOK
                    solve( !KU( ~MacAdd.1 ) @ #vk.16 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na,
                                     ~Nb, ~rr, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                             ) @ #vk.21 )
                        case InitDSendEa
                        solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                       ~Nb, ~Na, '0', IOCapabilityR, ~MacAdd.1, ~MacAdd)
                               ) @ #vk.36 )
                          case c_f6
                          solve( !KU( fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                 ) @ #vk.48 )
                            case c_fst
                            solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                   ) @ #vk.49 )
                              case c_f5
                              solve( !KU( 'g'^(~skI*~skR) ) @ #vk.50 )
                                case InitDSendDH
                                by solve( !KU( ~skR ) @ #vk.51 )
                              next
                                case ResDRecDHSendDH
                                by solve( !KU( ~skI ) @ #vk.51 )
                              next
                                case c_exp
                                by solve( !KU( ~skI ) @ #vk.53 )
                              qed
                            qed
                          qed
                        qed
                      next
                        case c_f6
                        by solve( !KU( ~rr ) @ #vk.50 )
                      qed
                    qed
                  qed
                qed
              qed
            next
              case InitDSendEa_case_2
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.2 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.2 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR,
                                       ra, rb, Na.2, ~Nb.2
                         ) ▶₁ #i.2 )
                    case OOB_ResDOK
                    solve( !KU( ~MacAdd.1 ) @ #vk.16 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na,
                                     ~Nb, ~rr, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                             ) @ #vk.21 )
                        case c_f6
                        by solve( !KU( ~rr ) @ #vk.49 )
                      qed
                    qed
                  qed
                qed
              qed
            next
              case InitDSendEa_case_3
              solve( Commit_Res( ~MacAdd.1, ~MacAdd, <'LTK', LTKR> ) @ #i.2 )
                case ResDSendEb
                solve( !InitDKeySize( KeySizeInit.1 ) ▶₀ #i.2 )
                  case ResDSResponseWithOOBflagR1
                  solve( State_Res_OK( ResD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                       ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR,
                                       ra, rb, Na.2, ~Nb.2
                         ) ▶₁ #i.2 )
                    case OOB_ResDOK
                    solve( !KU( ~MacAdd.1 ) @ #vk.16 )
                      case Advertising
                      solve( !KU( f6(fst(f5('g'^(~skI*~skR), Na, ~Nb, ~MacAdd, ~MacAdd.1)), Na,
                                     ~Nb, ~rr, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                             ) @ #vk.21 )
                        case InitDSendEa
                        solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                       ~Nb, ~Na, ~ri.1, IOCapabilityR, ~MacAdd.1, ~MacAdd)
                               ) @ #vk.39 )
                          case ResDSendEb
                          solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                    ~MacAdd.1)),
                                             KeySizeRes)
                                 ) @ #vk.16 )
                            case c_resize
                            solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                   ) @ #vk.46 )
                              case c_snd
                              solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                     ) @ #vk.47 )
                                case c_f5
                                solve( !KU( 'g'^(~skI*~skR) ) @ #vk.48 )
                                  case InitDSendDH
                                  by solve( !KU( ~skR ) @ #vk.49 )
                                next
                                  case ResDRecDHSendDH
                                  by solve( !KU( ~skI ) @ #vk.49 )
                                next
                                  case c_exp
                                  by solve( !KU( ~skI ) @ #vk.51 )
                                qed
                              qed
                            qed
                          next
                            case oracle
                            solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                      ~MacAdd.1)),
                                               KeySizeInit)
                                   ) @ #vk.18 )
                              case c_resize
                              solve( !KU( snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1))
                                     ) @ #vk.47 )
                                case c_snd
                                solve( !KU( f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)
                                       ) @ #vk.48 )
                                  case c_f5
                                  solve( !KU( 'g'^(~skI*~skR) ) @ #vk.49 )
                                    case InitDSendDH
                                    by solve( !KU( ~skR ) @ #vk.50 )
                                  next
                                    case ResDRecDHSendDH
                                    by solve( !KU( ~skI ) @ #vk.50 )
                                  next
                                    case c_exp
                                    by solve( !KU( ~skI ) @ #vk.52 )
                                  qed
                                qed
                              qed
                            next
                              case oracle
                              by contradiction /* from formulas */
                            qed
                          qed
                        next
                          case c_f6
                          by solve( !KU( ~ri.1 ) @ #vk.48 )
                        qed
                      next
                        case c_f6
                        by solve( !KU( ~rr ) @ #vk.49 )
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma LTKCP:
  all-traces
  "∀ I R LTKI LTKR #i #j.
    ((LTK( I, R, LTKI ) @ #i) ∧ (LTK( R, I, LTKR ) @ #j)) ⇒
    (¬(((¬(∀ #i.1.
            (Commit_Init( I, R, <'LTK', LTKI> ) @ #i.1) ⇒
            ((∃ #j.1. Running_Res( R, I, <'LTK', LTKI> ) @ #j.1) ∨
             (∃ #k. InitDJW( ) @ #k)))) ∧
        (¬(∀ #i.1.
            (Commit_Res( R, I, <'LTK', LTKR> ) @ #i.1) ⇒
            ((∃ #j.1. Running_Init( I, R, <'LTK', LTKR> ) @ #j.1) ∨
             (∃ #k. ResDJW( ) @ #k))))) ∧
       (¬(∃ #t1 #t2. (K( LTKI ) @ #t1) ∧ (K( LTKR ) @ #t2)))))"
/*
guarded formula characterizing all counter-examples:
"∃ I R LTKI LTKR #i #j.
  (LTK( I, R, LTKI ) @ #i) ∧ (LTK( R, I, LTKR ) @ #j)
 ∧
  (∃ #i.1.
    (Commit_Init( I, R, <'LTK', LTKI> ) @ #i.1)
   ∧
    (∀ #j.1. (Running_Res( R, I, <'LTK', LTKI> ) @ #j.1) ⇒ ⊥) ∧
    (∀ #k. (InitDJW( ) @ #k) ⇒ ⊥)) ∧
  (∃ #i.1.
    (Commit_Res( R, I, <'LTK', LTKR> ) @ #i.1)
   ∧
    (∀ #j.1. (Running_Init( I, R, <'LTK', LTKR> ) @ #j.1) ⇒ ⊥) ∧
    (∀ #k. (ResDJW( ) @ #k) ⇒ ⊥)) ∧
  (∀ #t1 #t2. (K( LTKI ) @ #t1) ∧ (K( LTKR ) @ #t2) ⇒ ⊥)"
*/
simplify
solve( LTK( I, R, LTKI ) @ #i )
  case InitDCheck
  solve( InitDSentEa( InitD, I, IOCapabilityI, OOBflagI, MITMI, R,
                      IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                      MacKeyI, LTKI
         ) ▶₀ #i )
    case InitDSendEa_case_09
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k )
        case ResDInOOBinfo
        solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                             ResD, MacAddR
               ) ▶₀ #k.1 )
          case Scan
          solve( LTK( ~MacAdd.1, ~MacAdd, LTKR ) @ #j )
            case ResDSendEb
            solve( !InitDKeySize( KeySizeInit ) ▶₀ #j )
              case ResDSResponseWithOOBflagR1
              solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI,
                                   ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI, DHKeyR, ra,
                                   rb, Na.1, ~Nb.1
                     ) ▶₁ #j )
                case OOB_ResDOK_case_2
                solve( Commit_Init( ~MacAdd, ~MacAdd.1,
                                    <'LTK', 
                                     resize(snd(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), KeySizeRes)
                                    >
                       ) @ #i.1 )
                  case InitDCheck
                  solve( InitDSentEa( InitD.1, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                      ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skI.1, DHpkR, DHKeyI,
                                      ra, rb, ~Na.2, Nb.2, MacKeyI,
                                      resize(snd(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)),
                                             KeySizeRes)
                         ) ▶₀ #i.1 )
                    case InitDSendEa
                    solve( Commit_Res( ~MacAdd.1, ~MacAdd,
                                       <'LTK', 
                                        resize(snd(f5(DHKeyR, Na.1, ~Nb.1, ~MacAdd, ~MacAdd.1)), KeySizeInit)>
                           ) @ #i.1 )
                      case ResDSendEb
                      solve( !InitDKeySize( KeySizeInit ) ▶₀ #i.1 )
                        case ResDSResponseWithOOBflagR1
                        solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                             ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI.1,
                                             DHKeyR, ra, rb, Na.1, ~Nb.1
                               ) ▶₁ #i.1 )
                          case OOB_ResDOK
                          solve( !KU( ~MacAdd.1 ) @ #vk.1 )
                            case Advertising
                            solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), Nb,
                                           ~Na, '0', IOCapabilityR, ~MacAdd.1, ~MacAdd)
                                   ) @ #vk.19 )
                              case ResDSendEb
                              solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                             ~Na, ~Nb, ~rr.1, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                                     ) @ #vk.43 )
                                case InitDSendEa
                                solve( !KU( ~MacAdd ) @ #vk.17 )
                                  case InitDRequestWithOOBflagI1
                                  solve( !KU( ~Na ) @ #vk.43 )
                                    case OOB_InitDSendNonce
                                    solve( !KU( ~Nb ) @ #vk.34 )
                                      case OOB_ResDOK
                                      solve( !KU( 'g'^~skR ) @ #vk.36 )
                                        case ResDRecDHSendDH
                                        solve( !KU( 'g'^~skI ) @ #vk.44 )
                                          case InitDSendDH
                                          SOLVED // trace found
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma SecAuthLTK:
  all-traces
  "∀ I R LTK #i #j.
    ((FSecAuthLTK( I, R, LTK ) @ #i) ∧ (FSecAuthLTK( R, I, LTK ) @ #j)) ⇒
    (((∀ #i.1.
        (Commit_Init( I, R, <'LTK', LTK> ) @ #i.1) ⇒
        (∃ #j.1. Running_Res( R, I, <'LTK', LTK> ) @ #j.1)) ∧
      (∀ #i.1.
        (Commit_Res( R, I, <'LTK', LTK> ) @ #i.1) ⇒
        (∃ #j.1. Running_Init( I, R, <'LTK', LTK> ) @ #j.1))) ⇒
     (¬(∃ #k. K( LTK ) @ #k)))"
/*
guarded formula characterizing all counter-examples:
"∃ I R LTK #i #j.
  (FSecAuthLTK( I, R, LTK ) @ #i) ∧ (FSecAuthLTK( R, I, LTK ) @ #j)
 ∧
  (∀ #i.1.
    (Commit_Init( I, R, <'LTK', LTK> ) @ #i.1)
   ⇒
    ∃ #j.1. (Running_Res( R, I, <'LTK', LTK> ) @ #j.1)) ∧
  (∀ #i.1.
    (Commit_Res( R, I, <'LTK', LTK> ) @ #i.1)
   ⇒
    ∃ #j.1. (Running_Init( I, R, <'LTK', LTK> ) @ #j.1)) ∧
  (∃ #k. (K( LTK ) @ #k))"
*/
simplify
solve( FSecAuthLTK( I, R, LTK ) @ #i )
  case InitDCheck
  solve( InitDSentEa( InitD, I, IOCapabilityI, OOBflagI, MITMI, R,
                      IOCapabilityR, OOBflagR, MITMR, ~skI, DHpkR, DHKeyI, ra, rb, ~Na, Nb,
                      MacKeyI, LTK
         ) ▶₀ #i )
    case InitDSendEa_case_09
    solve( !Device( ResD.1, MacAddR, IOCapabilityR.1, OOBCapabilityR,
                    MITMR.1, ~skR.1, 'Responder'
           ) ▶₁ #k.1 )
      case Init_ResDevice
      solve( !State_ResD_RevOOBInfo( MacAddI, ra, Ca ) ▶₂ #k.1 )
        case ResDInOOBinfo
        solve( State_Scaned( InitD.1, MacAddI, IOCapabilityI.1, MITMI.1, ~skI.1,
                             ResD.1, MacAddR
               ) ▶₀ #k.2 )
          case Scan
          solve( FSecAuthLTK( ~MacAdd.1, ~MacAdd,
                              resize(snd(f5('g'^(~skI*~skR), ~Na, Nb, ~MacAdd, ~MacAdd.1)), KeySizeRes)
                 ) @ #j )
            case ResDSendEb
            solve( !InitDKeySize( KeySizeRes ) ▶₀ #j )
              case ResDSResponseWithOOBflagR1
              solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI, OOBflagI, MITMI,
                                   ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI,
                                   'g'^(~skI*~skR), ra, rb, ~Na, ~Nb
                     ) ▶₁ #j )
                case OOB_ResDOK_case_2
                solve( Running_Res( ~MacAdd.1, ~MacAdd,
                                    <'LTK', 
                                     resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                            KeySizeInit)
                                    >
                       ) @ #j.1 )
                  case ResDSendEb
                  solve( !InitDKeySize( KeySizeInit ) ▶₀ #j.1 )
                    case ResDSResponseWithOOBflagR1
                    solve( State_Res_OK( ResD, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                         ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skR.1, DHpkI,
                                         'g'^(~skI*~skR), ra, rb, ~Na, ~Nb
                           ) ▶₁ #j.1 )
                      case OOB_ResDOK
                      solve( Running_Init( ~MacAdd, ~MacAdd.1,
                                           <'LTK', 
                                            resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                                   KeySizeInit)
                                           >
                             ) @ #j.1 )
                        case InitDSendEa
                        solve( !ResDKeySize( KeySizeInit ) ▶₀ #j.1 )
                          case InitDStartPairing
                          solve( State_Init_OK( InitD, ~MacAdd, IOCapabilityI.1, OOBflagI, MITMI.1,
                                                ~MacAdd.1, IOCapabilityR.1, OOBflagR, MITMR.1, ~skI.1, DHpkR,
                                                'g'^(~skI*~skR), ra, rb, ~Na, ~Nb
                                 ) ▶₁ #j.1 )
                            case OOB_InitDOK
                            solve( !KU( ~MacAdd.1 ) @ #vk.2 )
                              case Advertising
                              solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                             ~Nb, ~Na, '0', IOCapabilityR, ~MacAdd.1, ~MacAdd)
                                     ) @ #vk.20 )
                                case ResDSendEb
                                solve( !KU( resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                          ~MacAdd.1)),
                                                   KeySizeInit)
                                       ) @ #vk.11 )
                                  case oracle
                                  solve( !KU( f6(fst(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd, ~MacAdd.1)),
                                                 ~Na, ~Nb, ~rr.1, IOCapabilityI, ~MacAdd, ~MacAdd.1)
                                         ) @ #vk.43 )
                                    case InitDSendEa
                                    solve( !KU( senc(m,
                                                     resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                                   ~MacAdd.1)),
                                                            '7'))
                                           ) @ #vk.45 )
                                      case InitDDistribution
                                      solve( !KU( senc(<IRKR, BD_ADDRR, CSRKR>,
                                                       resize(snd(f5('g'^(~skI*~skR), ~Na, ~Nb, ~MacAdd,
                                                                     ~MacAdd.1)),
                                                              '7'))
                                             ) @ #vk.48 )
                                        case ResDDistribution
                                        solve( !KU( ~MacAdd ) @ #vk.21 )
                                          case InitDRequestWithOOBflagI1
                                          solve( !KU( ~Nb ) @ #vk.40 )
                                            case OOB_ResDOK
                                            solve( !KU( ~Na ) @ #vk.47 )
                                              case OOB_InitDSendNonce
                                              solve( !KU( 'g'^~skR ) @ #vk.43 )
                                                case ResDRecDHSendDH
                                                solve( !KU( 'g'^~skI ) @ #vk.48 )
                                                  case InitDSendDH
                                                  SOLVED // trace found
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.


analyzing: ./BLEResults/Unfixed/OOB/BLE_SC-1111.spthy

------------------------------------------------------------------------------
analyzed: ./BLEResults/Unfixed/OOB/BLE_SC-1111.spthy

  output:          ./BLEResults/Unfixed/OOB/proofs/Out_All_BLE_SC-1111.spthy
  processing time: 1586.099651199s
  Executability (exists-trace): verified (16 steps)
  IAuthRwithDHKey (all-traces): verified (48 steps)
  RAuthIwithDHKey (all-traces): verified (42 steps)
  IAuthRwithLTK (all-traces): falsified - found trace (15 steps)
  RAuthIwithLTK (all-traces): falsified - found trace (14 steps)
  MITMP (all-traces): verified (335 steps)
  LTKCP (all-traces): falsified - found trace (23 steps)
  SecAuthLTK (all-traces): falsified - found trace (27 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: ./BLEResults/Unfixed/OOB/BLE_SC-1111.spthy

  output:          ./BLEResults/Unfixed/OOB/proofs/Out_All_BLE_SC-1111.spthy
  processing time: 1586.099651199s
  Executability (exists-trace): verified (16 steps)
  IAuthRwithDHKey (all-traces): verified (48 steps)
  RAuthIwithDHKey (all-traces): verified (42 steps)
  IAuthRwithLTK (all-traces): falsified - found trace (15 steps)
  RAuthIwithLTK (all-traces): falsified - found trace (14 steps)
  MITMP (all-traces): verified (335 steps)
  LTKCP (all-traces): falsified - found trace (23 steps)
  SecAuthLTK (all-traces): falsified - found trace (27 steps)

==============================================================================
